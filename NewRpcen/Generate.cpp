/**
 * Project: Phoenix
 * Time-stamp: <2025-03-13 12:09:03 doug>
 * 
 * @file Generate.cpp
 * @author Douglas Mark Royer
 * @date 24-FEB-2025
 * 
 * @Copyright(C) 2025 by Douglas Mark Royer (A.K.A. RiverExplorer)
 * 
 * Licensed under the MIT License. See LICENSE file
 * or https://opensource.org/licenses/MIT for details.
 * 
 * RiverExplorer is a trademark of Douglas Mark Royer
 */

#ifndef W64
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#endif

#include "rpcgen.hpp"
#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>

#include "antlr4-runtime.h"
#include "xdrLexer.h"
#include "xdrParser.h"
#include "xdrListener.h"
#include "xdrBaseListener.h"

#include <unistd.h>
#include <getopt.h>
#include <fcntl.h>
#include <sys/stat.h>

#include "Generate.hpp"

#include <iostream>

using namespace antlr4;
using namespace std;

namespace RiverExplorer::rpcgen
{
	extern std::string	Indent(int Level);

	bool
	MakePath(const string PathToMake)
	{
		bool Results = false;
		
		// Break it down and make the parts.
		//
		string Path;
		string::const_iterator SIt;

		for (SIt = PathToMake.cbegin(); SIt != PathToMake.cend(); SIt++) {
			if (*SIt != '/' && *SIt != '\\') {
				Path += *SIt;
			} else {
				// If it does not exist.
				//
				mkdir(Path.c_str(), 0755);
				Path += '/';
			}
		}
		mkdir(Path.c_str(), 0755);
		
		if (access(PathToMake.c_str(), R_OK|W_OK|X_OK) == F_OK) {
			Results = true;
		} else {
			cerr
				<< "ERROR: Can not make or write to path:" << PathToMake
				<< endl;
		}

		return(Results);
	}
	
}

namespace RiverExplorer::rpcgen
{

	string
	RemoveFileExtension(string FileName)
	{
		string Results;
	
		size_t	LastDot = FileName.find_last_of('.');

		if (LastDot == string::npos) {
			Results = FileName;
		} else {
			Results = FileName.substr(0, LastDot);
		}

		return(Results);
	}
	
	static vector<string> XdrBuiltInTypes = {
		"bool",
		"char",
		"double",
		"emum",
		"float",
		"hyper",
		"int",
		"int16_t",
		"int64_t",
		"int8_t",
		"long",
		"opaque",
		"short",
		"string",
		"u_char",
		"u_int",
		"uint16_t",
		"uint64_t",
		"uint8_t",
		"u_long",
		"u_short"
	};
	
	bool IsBuiltInXdrType(const string & Type)
	{
		return(binary_search(XdrBuiltInTypes.begin(),
												 XdrBuiltInTypes.end(),
												 Type));
	}

	string
	Indent()
	{
		static string LastResults;
		static int LastIndent = 10000;
		
		string Results;

		if (IndentLevel != LastIndent) {
			int Tmp = IndentLevel;

			while (Tmp-- > 0) {
				Results += '\t';
			}
			LastIndent = IndentLevel;
			LastResults = Results;
		} else {
			Results = LastResults;
		}

		return(LastResults);
	}
		 
	string
	Indent(int Level)
	{
		string Results;

		int Tmp = Level;

		while (Tmp-- > 0) {
			Results += '\t';
		}

		return(Results);
	}
	
	string
	ToUpper(const string & In)
	{
		string Results = In;
	
		transform(Results.begin(),
							Results.end(),
							Results.begin(),
							[](unsigned char c) {return toupper(c);}
							);

		return(Results);
	}

	void
	GenerateThisFileWasGenerated(string Prefix,
															 ofstream & Stream)
	{
		Stream << Prefix << "DO NOT EDIT THIS FILE" << endl;
		Stream << Prefix << endl;
		Stream << Prefix
					 << "It was generated from: " << InputFileName << endl;
		
		Stream << Prefix
					 << "Using RiverExplorer rpcgen++ program." << endl;
		
		Stream << Prefix
					 << "Available at: https://github.com/Phoenix." << endl;

		return;
	}

	void
	GenerateEditThisFile(string Prefix,
											 ofstream & Stream)
	{
		Stream << Prefix << "EDIT THIS FILE AND PUT IN YOUR IMPLEMENTATION" << endl;
		Stream << Prefix << endl;
		Stream << Prefix
					 << "It was generated from: " << InputFileName << endl;
		
		Stream << Prefix
					 << "Using RiverExplorer rpcgen++ program." << endl;
		
		Stream << Prefix
					 << "Available at: https://github.com/Phoenix." << endl;

		return;
	}
}
