<?xml version="1.0" encoding="utf-8"?>
<?xml-model href="rfc7991bis.rnc"?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->
<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
	category="std"
  docName="draft-royer-phoenix-00"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  version="3"
	indexInclude="true"
	tocDepth="6"
	sortRefs="true">
  <front>
    <title abbrev="Phoenix: Lemonade Risen Again">Phoenix: Lemonade Risen Again</title>
    <seriesInfo name="Internet-Draft" value="draft-royer-phoenix-00"/>
   
    <author fullname="Doug Royer" initials="DM" surname="Royer">
      <organization>RiverExplorer LLC</organization>
      <address>
        <postal>
          <!-- Reorder these if your country does things differently -->
          <street>848 N. Rainbow Blvd #1120</street>
          <city>Las Vegas</city>
          <region>Nevada</region>
          <code>89107</code>
          <country>US</country>
          <!-- Uses two letter country code -->
        </postal>        
        <phone>1+208-806-1358</phone>
        <email>DouglasRoyer@gmail.com</email>  
        <!-- Can have more than one <email> element -->
        <uri>https://DougRoyer.US</uri>
      </address>
    </author>
   
    <date year="2025"/>
    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>imap</keyword>
    <keyword>pop</keyword>
    <keyword>smtp</keyword>
    <keyword>mime</keyword>
    <keyword>lemonade</keyword>
    <keyword>phoenix</keyword>
    <xi:include href="Abstract.xml"/>
  </front>

  <middle> 
    <xi:include href="RequirementsLanguage.xml"/>
    <xi:include href="Introduction.xml"/>
    <xi:include href="CBOR.xml"/>
    <xi:include href="Definitions.xml"/>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->

<section xmlns:xi="http://www.w3.org/2001/XInclude">
	<name>Commands</name>
	<t>
		The endpoint that initiates the connection is called the client.
    The endpoint that is connected to, is called the server.
    The client is the protocol authority, and the server responds
    to client commands as configured or instructed by the client.
  </t>
	<t>
		This section provides an overview of the basic commands.
		Each command has a detailed section in this specification.
	</t>
	<t>
		When a command is sent to the remote endpoint and received,
		the remote endpoint determines if the connection is authenticated
		or authorized to perform the command.
		If not supported, or not authorized, a NotSupported command
		is send as a reply.
		The NotSupported command sent back has the same Sequence number 
		that was in the original command.
	</t>
	<t>
		Many commands are only valid after authentication.
	</t>
	<t>
		When the client connects to a server it immediately sends
		a CAPABILITY_PRE list to the server.
		Or the client sends an AUTH command.
	</t>
	<t>
		When the server gets a new connection followed by
		a pre authentication capability command, it immediately sends
		its pre authentication capabilities to the client.
	</t>
	<t>
		When the client and server have had a relationship, the
		client may send an Auth Command to initiate the authorization
		and does not send its pre authentication capability list
		to the server.
		The client then waits for the Auth reply from the server.
	</t>
	<ul>
		<li>
			If the client gets a successful Auth reply,
			then the client sends its post authentication capability list to the server.
		</li>
		<li>
			If the client get an unsuccessful Auth reply,
			then the client sends its pre authentication
			capability list to the server followed by another
			Auth command.
			Upon too many retries, the server or client may terminate
			the connection.
		</li>
	</ul>
	<t>
		When a servers first received packet is a Auth command,
		It processes the Auth command and sends the Auth reply.
	</t>
	<ul>
		<li>
			If the Auth was successful, then the server sends
			a post authentication capability list.
		</li>
		<li>
			If the Auth was unsuccessful, then the server sends its
			pre authentication capability list to the client.
		</li>
	</ul>
	<t>
		When the server gets a new connection, it waits for
		a packet from the client. It will be a pre authentication
		capability packet, or a authentication packet.
		When the server has an unauthenticated connection, it
		only accepts two kinds of packets:
	</t>
	<ul>
		<li>
			A pre authentication capability packet.
			Which is replied to by the server with its pre authentication
			packet.
		</li>
		<li>An authentication packet.</li>
	</ul>
	<t>
			Upon too many retries, the server or client may terminate
			the connection.
	</t>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->

<section xmlns:xi="http://www.w3.org/2001/XInclude">
	<name>Commands Overview - Packet and Reply</name>
	<t>
		In addition to the protocols listed in this specification.
		Additional protocols and commands can be added in the future.
		They must follow the same framework listed here.
	</t>
	<t>
		This protocol connects two endpoints over a network and facilitates
		the secure and authorized transfer of MIME and other objects.
	</t>
	<t>
		This is a binary protocol encoded using CBOR streaming.
		The payload can be anything, text or binary.
		This protocol was designed to reduce the number of back and forth
		requests and replies between the client and server.
		By using CBOR as the format for transferring binary control
		information it is portable to any computer architecture.
	</t>
	<t>
		The basic connection starts in one of two modes.
	</t>
	<ul>
		<li>
			An account is connecting to a server for the first time
			and does not know which authentication methods the
			server supports.
		</li>
		<li>
			An account has authenticated to a server in the past or the
			client is already aware of a valid authentication protocol
			to use.
		</li>
	</ul>
	<t>
		When connection is made, the server waits for a packet from
		the client.
		It will be one of two kinds.
	</t>
	<ul>
		<li>A pre authentication capability packet (CAPABILITY_PRE).</li>
		<li>An authentication packet. (AUTH...).</li>
	</ul>
	<t>
		If the first packet the server receives
		is a pre authentication capability packet,
		The server examines the clients packet and determines what
		authentication options to present to the client.
		The server then sends back its pre authentication capability packet
		which includes the supported authentication methods.
		Then the client, using the information from the server starts
		the authentication process.
		On a successful authentication, the server sends the client
		a post authentication capability packet with a new sequence number.
	</t>
	<t>
		If the first packet the server receives is any of the supported
		authentication packets, then the server processes the authentication
		packet.
		On failure to authenticate, the server sends the client a pre
		authentication capability packet with the same sequence number
		that was in the authentication attempt and includes the
		servers supported authentication methods.
		On a successful authentication, the server sends the client
		a post authentication capability packet with a new sequence number.
	</t>
	<t>
		After the connection is successful and authenticated, ether endpoint
		may send commands to the other endpoint.
		When the server initiates an unsolicited command, it could be a
		any kind of notification or message for the client side application
		or the user. It could be reporting errors or updates to
		previous client initiated commands.
	</t>
	<ul>
		<li>
			All commands initiated from the client have even
			numbered command sequence numbers.
		</li>
		<li>
			All commands initiated from the server have odd
			numbered command sequence numbers.
		</li>
	</ul>
	<t>
		Some commands expect a command reply.
		Other commands do not expect a command reply.
		An example of a command that expects a reply is the ping command.
		An example of a command that does not expect a reply is the keep-alive
		command.
		Conceptually there are two kinds of commands:
	</t>
	<dl>
		<dt>Directive commands:</dt>
		<dd>
			A directive type command expects the other endpoint to process
			the command and possibly reply with some results.
			An example could be: Send me an index of my emails in my InBox.
			The client would expect a result.
			Another example is a bye command, once sent, no reply is expected.
		</dd>
		<dt>Request commands:</dt>
		<dd>
			A request type command may or might not have any reply.
			For example, a keep-alive command is a request to not
			timeout and has no reply.
			And a send new email notifications command would expect
			zero or more replies and it would not require them, as they
			might not happen.
		</dd>
	</dl>
	<t>
		These are not specific protocol entities, these concepts will
		be used to describe the expected behavior when one of these
		are transmitted.
	</t>
	<section anchor="PACKET_SUMMARY">
		<name>Packet Overview</name>
		<t>
			All commands are sent in a packet.
			A packet has two parts:
		</t>
		<ol>
			<li>The packet header.</li>
			<li>The packet body.</li>
		</ol>
		<section>
			<name>Packet Header</name>
			<t>
				The packet header has one value, the total length
				of the packet body, and payload sent as an
				CBOR unsigned integer.
				The length does not include its own length.
				It is the total length that follows the length value.
			</t>
			<table>
				<name>Packet Header ABNF/CBOR Mapping</name>
				<thead>
					<tr>
						<th>
							Name
						</th>
						<th>
							Description
						</th>
						<th>
							CBOR API
						</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							PacketHeader
						</td>
						<td>
							<t>
								The number of octets that follow this value that
								are part of this packet.
							</t>
						</td>
						<td>
							cbor_PacketHeader()
						</td>
					</tr>
				</tbody>
			</table>
			<section>
				<name>Packet Header ABNF</name>
				<t>
					ABNF:
				</t>
				<figure>
					<name>Packet Header ABNF</name>
					<xi:include href="include/03-PacketHeader-ABNF.xml"/>
				</figure>
			</section>
			<section>
				<name>Packet Header CBOR</name>
				<t>
					CBOR Definition:
				</t>
				<figure>
					<name>Packet Header CBOR</name>
					<xi:include href="include/03-PacketHeader-XDR.xml"/>
				</figure>
			</section>
		</section>

		<section>
			<name>Packet Body (PacketBody)</name>
			<t>
				The packet body is divided into four parts:
			</t>
			<ol>
				<li>Number of commands that are in the packet.</li>
				<li>Sequence (SEQ)</li>
				<li>
					Command (CMD):
				</li>
				<li>
					Payload (CmdPayload):
					The command specific data. 
				</li>
			</ol>
			<t>
				PacketBody details:
			</t>
			<table>
				<name>Packet Body ABNF/CBOR Mapping</name>
				<thead>
					<tr>
						<th>
							Name
						</th>
						<th>
							Value
						</th>
						<th>
							Description
						</th>
						<th>
							CBOR API
						</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							Length
						</td>
						<td>
							An unsigned integer
						</td>
						<td>
							The number of CMD objects in this packet.
						</td>
						<td>
							cbor_Length()
						</td>
					</tr>
					<tr>
						<td>
							SEQ
						</td>
						<td>
							uint32_t
						</td>
						<td>
							<t>
								The Command SEQ is a uint32_t.
								This SEQ is an even number when initiated from
								the client,	and an odd number when initiated
								from the server.
							</t>
							<t>
								Over the wire it is a CBOR unsigned integer.
							</t>
							<t>
								The first SEQ value sent from the client is zero (0)
								and is incremented by two each time.
							</t>
							<t>
								The first SEQ value sent from the server is one (1)
								and is incremented by two each time.
							</t>
							<t>
								In the event an endpoint command SEQ reaches its maximum
								value, then its numbering starts over at zero (0) for
								the client and one (1) for the server.
								An implementation must keep track of outstanding
								commands and not accidentally re-issue the same
								SEQ that may still get replies from the other endpoint.
							</t>
						</td>
						<td>
							cbor_SEQ()
						</td>
					</tr>
					<tr>
						<td>
							CMD
						</td>
						<td>
							1 bit + 31 bits.
						</td>
						<td>
							<t>
								A 31-bit value that is a Phoenix compliant
								command or a command with the VENDOR_BIT set
								(a vendor command).
							</t>
							<t>
								<br/>
								A command (CMD) is a unsigned integer that
								specifics a unique operation that describes
								and defines the data that follows.
							</t>
							<t>
								<br/>
								The highest bit in the 32-bit value is
								the VENDOR_BIT.
								CMD covers vendor and phoenix commands.
							</t>
							<ul>
								<li>
									Phoenix CMD range is: %x00000000-7fffffff.
								</li>
								<li>
									Vendor CMD range is: 80000000-fffffffe.
								</li>
								<li>
									With %xffffffff reserved.
								</li>
							</ul>
							<t>
								All vendor commands are followed by another
								32-bit Length value indicating how
								may octets follow the Length that are in the payload.
								This is so that compliant implementation that do
								not support the vendor extensions know how
								many octets to skip to find the next command
								or end of packet.
							</t>
						</td>
						<td>
							cbor_Cmd()
						</td>
					</tr>
					<tr>
						<td>
							CmdPayload
						</td>
						<td>
							Variable
						</td>
						<td>
							<t>
								The Payload is whatever data follows the command.
								In some cases it is a blob of opaque data.
								In other cases it is a structured CBOR set of data.
								See the specific CMD for details.
							</t>
						</td>
						<td>
							cbor_CmdPayload()
						</td>
					</tr>
				</tbody>
			</table>
			<t>
				A command conforming to this specification is not
				a vendor command.
				A command created by any vendor that implements
				vendor specific commands or operations is a vendor
				command.
				Vendor commands have the VENDOR_BIT set in the
				commands or operations.
				And vendor commands MUST have a Length value
				that follows the command that indicates how
				many octets follow the length.
				This is so that implementations that do not understand
				the vendor extension can skip that many more octets
				to find the next command or operation.
			</t>
			<t>
				If any operation in a command has the VENDOR_BIT set
				it may effect implementations that do not support that
				specific vendor operation.
				So caution must be used when creating vendor command
				operation extensions.
			</t>
			<t>
				In this example the server is sending a CAPABILITY_PRE
				command telling the client that the server supports
				AUTHMD5 and some made up vendor authentication AUTH_Vendor_3.
				The AUTHMD5 does not have the VENDOR_BIT set, and
				AUTH_Vendor_e has the VENDOR_BIT set.
			</t>
			<t>
				Clients or servers that are not using vendor specific
				extensions, can:
			</t>
			<ul>
				<li>Send a VENDOR_ID with the value as an	empty string.</li>
				<li>
					Or set the string, and just do not send
					any command or command operations with extensions.
				</li>
			</ul>
			<t>
				Clients that do not understand the string value in VENDOR_ID
				would ignore the commands and capabilities with the
				VENDOR_BIT set.
				Which is AUTH_Vendor_3 in this example.
			</t>
			<t>
				<xref target="AuthPreEx1"/>
				is an example of a CAPABILITY_PRE being sent
				from the server to the client.
				A client that is conforming to this specification and
				does not support any vendor extensions, would ignore the
				AUTH_Vendor_3	and authenticate with AUTHMD5.
				NOTE: This is how the application sees the data,
				this is not the over the wire data as it is not
				in CBOR format.
			</t>
			<figure anchor="AuthPreEx1">
				<name>Packet Body Non-Vendor- Diagram</name>
				<artset>
					<artwork align="center" type="ascii-art" src="Drawings/Packet-01.txt"/>
          <artwork align="center" type="svg" src="Generated/Packet-01.svg"/>
				</artset>
			</figure>
			
			<t>
				In example <xref target="P01-01"/>, the server is telling the
				client that it is using a vendor specific AUTHMD5
				and a vendor specific AUTH_Vendor_e only.
			</t>
			<t>
				When when vendor specific extensions make the connection
				incompatible with implementations conforming to this
				specification, then it MUST also set the VENDOR_BIT in the command.
				In this example it is being set in the CAPABILITY_PRE command.
				A conforming client would then know that there are zero compatible
				authentication methods to this server.
				A client implementations that understand the contents of the string
				value for VENDOR_ID, may also understand these extensions.
			</t>
			<t>
				After each entry that has the VENDOR_BIT set, the next
				value must be a Length indicating how many octets of data
				follow the Length, even when zero.
			</t>
			<figure anchor="P01-01">
				<name>Packet Body Vendor - Diagram</name>
				<artset>
					<artwork align="center" type="ascii-art" src="Drawings/Packet-01-01.txt"/>
          <artwork align="center" type="svg" src="Generated/Packet-01-01.svg"/>
				</artset>
			</figure>

			<t>
				And the matching data for <xref target="P01-01"/> could be:
			</t>				
			<figure anchor="P01-02">
				<name>Packet Body Vendor - Diagram Data</name>
				<artset>
					<artwork align="center" type="ascii-art" src="Drawings/Packet-01-02.txt"/>
          <artwork align="center" type="svg" src="Generated/Packet-01-02.svg"/>
				</artset>
			</figure>
			<t>
				Note that the CAPABILITY_PRE in <xref target="P01-01"/> and <xref target="P01-02"/>
				has the VENDOR_BIT set, so it is followed by the number of octets
				in the vendor extension.
			</t>
			<t>
				Multiple commands may be sent in one packet.
				And PHOENIX and VENDOR commands may be sent
				in one packet body by setting VENDOR_BIT to (1).
				This example shows two commands and the start of a third,
				one that is a PHOENIX command	the other is a vendor command.
			</t>
			<figure>
				<name>Packet Body Multiple Commands - Diagram</name>
				<artset>
					<artwork align="center" type="ascii-art" src="Drawings/Packet-03.txt"/>
          <artwork align="center" type="svg" src="Generated/Packet-03.svg"/>
				</artset>
			</figure>
			
			<section>
				<name>Packet Body ABNF</name>
				<t>
					ABNF:
				</t>
				<figure>
					<name>Packet Body ABNF</name>
					<xi:include href="include/04-PacketBody-ABNF.xml"/>
				</figure>
			</section>
			<section>
				<name>Packet Body CBOR</name>
				<t>
					CBOR Definition:
				</t>
				<figure>
					<name>Packet Body CBOR</name>
					<xi:include href="include/04-PacketBody-XDR.xml"/>
				</figure>
			</section>

			<section>
				<name>Multiple Commands per Packet</name>
			</section>
		</section>
			
	</section>
	<section anchor="PACKET_REPLY_SUMMARY">
		<name>Packet Reply Overview</name>
		<t>
			All replies to a command are also a command packet.
			They contain the same command SEQ and command
			as the original packet.
			The endpoint recognizes it is a reply because:
		</t>
		<ul>
			<li>
				The	command SEQ matches one that is waiting a reply.
			</li>
			<li>
				When the client gets an even numbered SEQ, it can only
				be a reply.
			</li>
			<li>
				When the server gets an odd numbered
				SEQ, it can only be a reply.
			</li>
		</ul>
		<t>
			Some commands have zero to many replies.
			Each of these multiple replies contains the same SEQ as the
			original command. An example, the client sends a request
			to be notified when new email arrives and uses command
			SEQ 20. Each time a new email arrives, a reply will
			be sent from the server with a command SEQ of 20.
			And over time, the client may get many with a SEQ of 20
			as new emails arrive on the server.
		</t>
		<t>
			And like the original command, multiple replies may be
			in one packet.
		</t>
	</section>
</section>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->
<section xmlns:xi="http://www.w3.org/2001/XInclude">
	<name>Administration Commands</name>
	
	<t>
		Implementations are not required to implement any ADMIN command.
		A client will know the server supports one or more ADMIN
		commands when it gets a CAPABILITY_POST with an ADMIN capability
		in it, from the server.
	</t>
	<t>
		Administrative command can be used to configure, audit, and manage
		the remote endpoint.
		Administrative command can be used to configure, audit, and manage
		user access for the server implementation.
	</t>

	<section>
		<name>Administration Capability Definitions</name>
		<t>
			Implementations MUST NOT send any ADMIN capability
			in the CAPABILITY_PRE list.
		</t>
		<t>
			Implementations that support any administration command
			will include an ADMIN capability in the CAPABILITY_POST list.
			An implementation may decide that only specified and
			authorized users may issue administrative commands and
			send only those authenticated users an ADMIN capability.
		</t>
		<t>
			The ADMIN capability includes the list of ADMIN commands the user is
			allowed to perform.
			For example, if a user only has permission to only view user lists, then
			only the USER_LIST ADMIN capability will be provided.
		</t>
		<t>
			The capability name is also the command name to use
			when invoking that capability.
		</t>
		<t>
			When a user attempts to send a commmand they are not authorized
			to send, the remote endpoint will reply with a NOT_SUPPORTED command
			with its sequence number set to the sequence number from offending
			command.
		</t>
	</section>

	<section>
		<name>Administration Command Payload</name>
		<t>
			To simplify naming, the capability names and command/reply names
			are the same.
		</t>
		<t>
			The following operations are defined for administration.
			Each is part of an ADMIN command or ADMIN reply.
			They each have a unique identifier, called an ADMIN CMD.
		</t>
		<t>
			All of their CBOR API is: cbor_CMD().
		</t>
		<table>
			<name>Administration Comamnd Payload Operations</name>
			<thead>
				<tr>
					<th>Name</th>
					<th>CMD</th>
					<th>Capability Description.</th>
					<th>Command Description.</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td></td>
					<td>CMD</td>
					<td>
						An Administrative Operation Identifier.
					</td>
					<td>
						Holds the (VENDOR_BIT or PHOENIX_BIT) value
						and one of ADMIN commands described in this section.
					</td>
				</tr>
				<tr>
					<td>SERVER_CONFIGURE</td>
					<td>%x05:8</td>
					<td>
						May configure the server.
						A reply may have zero to many of the reply values
						set to READ_ONLY indicating the client may not
						alter them
					</td>
					<td>
						The command to view and alter the server configuration
						information.
					</td>
				</tr>
				<tr>
					<td>SERVER_KICK_USER</td>
					<td>%x06:8</td>
					<td>
						logs out a user. And may limit when they can use the server again.
					</td>
					<td>
						The command to kick and limit a user.
					</td>
				</tr>
				<tr>
					<td>SERVER_LOGS</td>
					<td>%x07:8</td>
					<td>
						May view the server logs.
					</td>
					<td>
						The command to view server logs.
					</td>
				</tr>
				<tr>
					<td>SERVER_MANAGE_BANS</td>
					<td>%x08:8</td>
					<td>
						May manage IP and user bans.
					</td>
					<td>
						The command to manage ban users and IP addresses.
					</td>
				</tr>
				<tr>
					<td>SERVER_SHUTDOWN</td>
					<td>%x09:8</td>
					<td>
						May shutdown the server.
					</td>
					<td>
						The command to shutdown the server.
					</td>
				</tr>
				<tr>
					<td>SERVER_VIEW_STATS</td>
					<td>%x0a:8</td>
					<td>
						May view server statistics.
					</td>
					<td>
						The command to view statistics.
					</td>
				</tr>
				<tr>
					<td>USER_CREATE</td>
					<td>%x0b:8</td>
					<td>
						May create a new user.
					</td>
					<td>
						The command to create a Phoenix server user.
					</td>
				</tr>
				<tr>
					<td>USER_DELETE</td>
					<td>%x0c:8</td>
					<td>
						May delete a user.
					</td>
					<td>
						The command to delete a user.
					</td>
				</tr>
				<tr>
					<td>USER_LIST</td>
					<td>%x0d:8</td>
					<td>
						May list users and their capabilities.
					</td>
					<td>
						The command to list users.
					</td>
				</tr>
				<tr>
					<td>USER_PERMISSIONS</td>
					<td>%x0e:8</td>
					<td>
						May update other users permissions.
					</td>
					<td>
						The command to view and set user permissions.
					</td>
				</tr>
				<tr>
					<td>USER_RENAME</td>
					<td>%x0f:8</td>
					<td>
						May rename a user.
					</td>
					<td>	
						The command to rename a user.
					</td>
				</tr>
			</tbody>
		</table>

	</section>
		
	<xi:include href="ServerConfigure.xml"/>
	<xi:include href="ServerKickUser.xml"/>
	<xi:include href="ServerLogs.xml"/>
	<xi:include href="ServerManageBans.xml"/>
	<xi:include href="ServerShutdown.xml"/>
	<xi:include href="ServerViewStats.xml"/>
	<xi:include href="UserCreate.xml"/>
	<xi:include href="UserDelete.xml"/>
	<xi:include href="UserList.xml"/>
	<xi:include href="UserPermissions.xml"/>
	<xi:include href="UserRename.xml"/>

</section>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->

<section anchor="AUTH_SUMMARY" xmlns:xi="http://www.w3.org/2001/XInclude">
	<name>Authentication Commands Summary</name>
	<t>
		The first thing a client must do, is authenticate
		with the server.
	</t>
	<t>
		Some users may also be administrators.
		In those cases the user and client may wish to do further
		authentication steps.
		A user may wish to temporarily step up their authentication
		level to perform some operations, then step back down
		to do their personal operations.
		This would be done on separate connection.
	</t>
	<t>
		A server may if it wishes include AUTH capabilities in
		the CAPABILITY_POST command.
		It can decide which authenticated users can or must use
		additional authentication.
	</t>
	<ul>
		<li>
			Some user accounts can be user only, without administrative
			abilities of any kind.
			Their CAPABILITY_POST list will not include any administrative
			capabilities.
		</li>
		<li>
			Some user accounts can be administrative only, and are limited
			to CAPABILITY_POST actions that only include administrative
			capabilities.
		</li>
		<li>
			Some user accounts can be a normal user, with the ability
			to step up their account to be able to do administrative actions.
			While in stepped up mode, they are not able to act as their
			original user account.
			These users will get one or more administrative capabilities in
			their CAPABILITY_POST list.
		</li>
		<li>
			And some user account can be allowed all operations.
			This protocol does not limit users.
			This protocol enables user permissions to be configured.
		</li>
	</ul>

	<section>
		<name>Authentication process</name>
		<t>
			The client initiates the authentication process.
			When the client makes a connection to a server it
			takes one of two paths, depending
			on [<xref target="AuthSummary01"/> (A)]:
		</t>
		<ul>
			<li>
				If it has never authenticated to this server using the
				current account.[<xref target="AuthSummary01"/> (L)]:
			</li>
			<li>
				If its last connection had a successful authentication
				to this server using the current account.
				[<xref target="AuthSummary01"/> (B)]:
			</li>
		</ul>
		<t>
			Part of the authentication process is determining which
			authentication process a server requires.
			So upon initial connection the client sends a CAPABILITY_PRE
			packet that includes all of the authentication methods
			it is willing to use.
			It is an ordered list with the more desirable ones at
			the front of the list, and the least desirable ones
			at the end if the list.
			And if the client wishes to do any vendor specific operations,
			then it must also	include the VENDOR_ID string in the
			initial packet.
		</t>
		<t>
			Similarly, the CAPABILITY_PRE packet sent from the server
			includes the same information.
			The server is the authentication mechanism authority.
		</t>
		<t>
			When a client sends a VENDOR_ID command in
			its CAPABILITY_PRE command, then the server MUST
			reply back in its CAPABILITY_PRE reply,
			its VENDOR_ID (It is valid for it to be empty).
			(See <xref target="VendorID">VendorID</xref>)
		</t>
		<figure anchor="AuthSummary01">
			<name>Authentication Overview</name>
			<artset>
<artwork type="ascii-art"><![CDATA[

                 CLIENT  |  SERVER
                 ------  |  ------
   (A)                   |
Have Previous            |
AUTH Success             |
 History?                |          AUTH PASS?
   .                     |               .
  / \                                   / \ (D)
 /   \  YES    SEND AUTH (B)           /   \
+  ?  +------+----------------------->+  ?  +-.
 \   /       | AND SEND CAPABILITY_PRE \   /   | P (E)
  \ /        |    (C)                   \ /    | A
   +         |                       (F) +     | S
   | NO      |                           | F   | S
   | (L)     |                           | A   |
   |         v (I)                       | I   |
   |      +--+--+     <--CAPABILITY_PRE  | L   |
   |      | WAIT |<---------------------'      |
   |      |      |<---------------------------'
   |      +--+---+    <--CAPABILITY_POST (G)
   |         |
   |         + (H) Got CAPABILITY_POST?
   |        / \ 
   |       /   \ YES (J)
   |      +  ?  +---> GO TO (Y) AUTHENTICATED.
   |       \   / 
   |        \ /
   |         + NO (K)
   |         |
   |         v
   |         GO TO START AUTH (Q)
   |
   v    (M)
+--+------------------+
| SEND CAPABILITY_PRE +------------------. 
+--+------------------+                  |
   |                                (N)  v
   |                                +----+----+
   |                                | SERVER  |
   |                                | SENDS   |
   |                                | CAP_PRE |
   v (O)                            +----+----+
+--+--+     <- CAPABILITY_PRE            |     
|Wait |<---------------------------------' (P)
+--+--+
   |
   |  (Q) START AUTH
   v  Any AUTH IN LIST WE CAN USE?
   +
  / \
 /   \  NO
+  ?  +----> UNABLE TO TALK (R)
 \   /       TO THIS SERVER!
  \ /
   +  YES (S)                       (T)
   |                                AUTH
   |    <-- SENT CAPABILITY_PRE     FAIL
   +<-------------------------------. 
   |                                 |
   |                                 +
   v (U)                         (V)/ \
+--+---+      AUTH -->             /   \
| AUTH +------------------------->+ OK? +
+--+---+                           \   /
   |                            (W) \ /
   |                           AUTH  +
   |                           PASS  |
+--+---+ (X)                         |
| WAIT |<---------------------------'
+--+---+  <-- SENT CAPABILITY_POST 
   |
   v
    (Y) CLIENT IS AUTHENTICATED

]]></artwork>
<artwork type="svg">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="1216" width="440" viewBox="0 0 440 1216" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
<path d="M 8,560 L 8,592" fill="none" stroke="black"/>
<path d="M 8,704 L 8,736" fill="none" stroke="black"/>
<path d="M 8,1008 L 8,1040" fill="none" stroke="black"/>
<path d="M 8,1104 L 8,1136" fill="none" stroke="black"/>
<path d="M 32,224 L 32,552" fill="none" stroke="black"/>
<path d="M 32,592 L 32,696" fill="none" stroke="black"/>
<path d="M 32,736 L 32,792" fill="none" stroke="black"/>
<path d="M 32,896 L 32,1000" fill="none" stroke="black"/>
<path d="M 32,1040 L 32,1104" fill="none" stroke="black"/>
<path d="M 32,1136 L 32,1168" fill="none" stroke="black"/>
<path d="M 56,704 L 56,736" fill="none" stroke="black"/>
<path d="M 64,1000 L 64,1040" fill="none" stroke="black"/>
<path d="M 64,1104 L 64,1136" fill="none" stroke="black"/>
<path d="M 88,288 L 88,336" fill="none" stroke="black"/>
<path d="M 112,176 L 112,280" fill="none" stroke="black"/>
<path d="M 112,336 L 112,368" fill="none" stroke="black"/>
<path d="M 112,464 L 112,496" fill="none" stroke="black"/>
<path d="M 144,304 L 144,336" fill="none" stroke="black"/>
<path d="M 184,560 L 184,592" fill="none" stroke="black"/>
<path d="M 208,32 L 208,128" fill="none" stroke="black"/>
<path d="M 296,616 L 296,688" fill="none" stroke="black"/>
<path d="M 304,960 L 304,976" fill="none" stroke="black"/>
<path d="M 304,1072 L 304,1104" fill="none" stroke="black"/>
<path d="M 336,224 L 336,288" fill="none" stroke="black"/>
<path d="M 336,576 L 336,616" fill="none" stroke="black"/>
<path d="M 336,688 L 336,720" fill="none" stroke="black"/>
<path d="M 376,624 L 376,688" fill="none" stroke="black"/>
<path d="M 384,192 L 384,304" fill="none" stroke="black"/>
<path d="M 144,48 L 184,48" fill="none" stroke="black"/>
<path d="M 232,48 L 272,48" fill="none" stroke="black"/>
<path d="M 56,176 L 304,176" fill="none" stroke="black"/>
<path d="M 360,176 L 368,176" fill="none" stroke="black"/>
<path d="M 88,288 L 128,288" fill="none" stroke="black"/>
<path d="M 184,288 L 200,288" fill="none" stroke="black"/>
<path d="M 152,304 L 320,304" fill="none" stroke="black"/>
<path d="M 152,320 L 368,320" fill="none" stroke="black"/>
<path d="M 88,336 L 144,336" fill="none" stroke="black"/>
<path d="M 184,336 L 200,336" fill="none" stroke="black"/>
<path d="M 136,416 L 168,416" fill="none" stroke="black"/>
<path d="M 8,560 L 184,560" fill="none" stroke="black"/>
<path d="M 184,576 L 336,576" fill="none" stroke="black"/>
<path d="M 8,592 L 184,592" fill="none" stroke="black"/>
<path d="M 296,624 L 376,624" fill="none" stroke="black"/>
<path d="M 296,688 L 376,688" fill="none" stroke="black"/>
<path d="M 8,704 L 48,704" fill="none" stroke="black"/>
<path d="M 64,720 L 336,720" fill="none" stroke="black"/>
<path d="M 8,736 L 56,736" fill="none" stroke="black"/>
<path d="M 56,848 L 96,848" fill="none" stroke="black"/>
<path d="M 72,928 L 88,928" fill="none" stroke="black"/>
<path d="M 40,944 L 288,944" fill="none" stroke="black"/>
<path d="M 8,1008 L 64,1008" fill="none" stroke="black"/>
<path d="M 160,1008 L 176,1008" fill="none" stroke="black"/>
<path d="M 64,1024 L 272,1024" fill="none" stroke="black"/>
<path d="M 8,1040 L 64,1040" fill="none" stroke="black"/>
<path d="M 8,1104 L 64,1104" fill="none" stroke="black"/>
<path d="M 72,1120 L 288,1120" fill="none" stroke="black"/>
<path d="M 8,1136 L 64,1136" fill="none" stroke="black"/>
<path d="M 88,1136 L 104,1136" fill="none" stroke="black"/>
<path d="M 8,848 L 32,896" fill="none" stroke="black"/>
<path d="M 32,800 L 56,848" fill="none" stroke="black"/>
<path d="M 280,1024 L 304,1072" fill="none" stroke="black"/>
<path d="M 304,976 L 328,1024" fill="none" stroke="black"/>
<path d="M 88,416 L 112,464" fill="none" stroke="black"/>
<path d="M 8,176 L 32,224" fill="none" stroke="black"/>
<path d="M 112,368 L 136,416" fill="none" stroke="black"/>
<path d="M 32,128 L 56,176" fill="none" stroke="black"/>
<path d="M 312,176 L 336,224" fill="none" stroke="black"/>
<path d="M 336,128 L 360,176" fill="none" stroke="black"/>
<path d="M 8,176 L 32,128" fill="none" stroke="black"/>
<path d="M 32,224 L 56,176" fill="none" stroke="black"/>
<path d="M 88,416 L 112,368" fill="none" stroke="black"/>
<path d="M 112,464 L 136,416" fill="none" stroke="black"/>
<path d="M 312,176 L 336,128" fill="none" stroke="black"/>
<path d="M 8,848 L 32,800" fill="none" stroke="black"/>
<path d="M 336,224 L 360,176" fill="none" stroke="black"/>
<path d="M 32,896 L 56,848" fill="none" stroke="black"/>
<path d="M 280,1024 L 304,976" fill="none" stroke="black"/>
<path d="M 304,1072 L 328,1024" fill="none" stroke="black"/>
<path d="M 368,176 C 376.83064,176 384,183.16936 384,192" fill="none" stroke="black"/>
<path d="M 128,288 C 136.83064,288 144,295.16936 144,304" fill="none" stroke="black"/>
<path d="M 320,304 C 328.83064,304 336,296.83064 336,288" fill="none" stroke="black"/>
<path d="M 368,320 C 376.83064,320 384,312.83064 384,304" fill="none" stroke="black"/>
<path d="M 288,944 C 296.83064,944 304,951.16936 304,960" fill="none" stroke="black"/>
<path d="M 288,1120 C 296.83064,1120 304,1112.83064 304,1104" fill="none" stroke="black"/>
<polygon class="arrowhead" points="344,616 332,610.4 332,621.6" fill="black" transform="rotate(90,336,616)"/>
<polygon class="arrowhead" points="312,176 300,170.4 300,181.6" fill="black" transform="rotate(0,304,176)"/>
<polygon class="arrowhead" points="280,1024 268,1018.4 268,1029.6" fill="black" transform="rotate(0,272,1024)"/>
<polygon class="arrowhead" points="192,336 180,330.4 180,341.6" fill="black" transform="rotate(180,184,336)"/>
<polygon class="arrowhead" points="192,288 180,282.4 180,293.6" fill="black" transform="rotate(180,184,288)"/>
<polygon class="arrowhead" points="184,1008 172,1002.4 172,1013.6" fill="black" transform="rotate(0,176,1008)"/>
<polygon class="arrowhead" points="176,416 164,410.4 164,421.6" fill="black" transform="rotate(0,168,416)"/>
<polygon class="arrowhead" points="160,320 148,314.4 148,325.6" fill="black" transform="rotate(180,152,320)"/>
<polygon class="arrowhead" points="160,304 148,298.4 148,309.6" fill="black" transform="rotate(180,152,304)"/>
<polygon class="arrowhead" points="120,496 108,490.4 108,501.6" fill="black" transform="rotate(90,112,496)"/>
<polygon class="arrowhead" points="120,280 108,274.4 108,285.6" fill="black" transform="rotate(90,112,280)"/>
<polygon class="arrowhead" points="104,848 92,842.4 92,853.6" fill="black" transform="rotate(0,96,848)"/>
<polygon class="arrowhead" points="96,1136 84,1130.4 84,1141.6" fill="black" transform="rotate(180,88,1136)"/>
<polygon class="arrowhead" points="80,1120 68,1114.4 68,1125.6" fill="black" transform="rotate(180,72,1120)"/>
<polygon class="arrowhead" points="80,928 68,922.4 68,933.6" fill="black" transform="rotate(180,72,928)"/>
<polygon class="arrowhead" points="72,720 60,714.4 60,725.6" fill="black" transform="rotate(180,64,720)"/>
<polygon class="arrowhead" points="48,944 36,938.4 36,949.6" fill="black" transform="rotate(180,40,944)"/>
<polygon class="arrowhead" points="40,1168 28,1162.4 28,1173.6" fill="black" transform="rotate(90,32,1168)"/>
<polygon class="arrowhead" points="40,1000 28,994.4 28,1005.6" fill="black" transform="rotate(90,32,1000)"/>
<polygon class="arrowhead" points="40,792 28,786.4 28,797.6" fill="black" transform="rotate(90,32,792)"/>
<polygon class="arrowhead" points="40,696 28,690.4 28,701.6" fill="black" transform="rotate(90,32,696)"/>
<polygon class="arrowhead" points="40,552 28,546.4 28,557.6" fill="black" transform="rotate(90,32,552)"/>
<g class="text">
<text x="164" y="36">CLIENT</text>
<text x="252" y="36">SERVER</text>
<text x="40" y="68">(A)</text>
<text x="56" y="84">Have Previous</text>
<text x="52" y="100">AUTH Success</text>
<text x="44" y="116">History?</text>
<text x="332" y="116">AUTH PASS?</text>
<text x="368" y="148">(D)</text>
<text x="80" y="164">YES</text>
<text x="176" y="164">SEND AUTH (B)</text>
<text x="32" y="180">?</text>
<text x="336" y="180">?</text>
<text x="216" y="196">AND SEND CAPABILITY_PRE</text>
<text x="416" y="196">P (E)</text>
<text x="160" y="212">(C)</text>
<text x="400" y="212">A</text>
<text x="312" y="228">(F)</text>
<text x="400" y="228">S</text>
<text x="52" y="244">NO</text>
<text x="352" y="244">F</text>
<text x="400" y="244">S</text>
<text x="56" y="260">(L)</text>
<text x="352" y="260">A</text>
<text x="136" y="276">(I)</text>
<text x="352" y="276">I</text>
<text x="260" y="292">CAPABILITY_PRE</text>
<text x="352" y="292">L</text>
<text x="116" y="308">WAIT</text>
<text x="280" y="340">CAPABILITY_POST (G)</text>
<text x="220" y="372">(H) Got CAPABILITY_POST?</text>
<text x="168" y="404">YES (J)</text>
<text x="112" y="420">?</text>
<text x="276" y="420">GO TO (Y) AUTHENTICATED.</text>
<text x="148" y="468">NO (K)</text>
<text x="188" y="516">GO TO START AUTH (Q)</text>
<text x="80" y="548">(M)</text>
<text x="96" y="580">SEND CAPABILITY_PRE</text>
<text x="304" y="612">(N)</text>
<text x="332" y="644">SERVER</text>
<text x="328" y="660">SENDS</text>
<text x="336" y="676">CAP_PRE</text>
<text x="56" y="692">(O)</text>
<text x="168" y="708">&lt;- CAPABILITY_PRE</text>
<text x="28" y="724">Wait</text>
<text x="360" y="724">(P)</text>
<text x="108" y="772">(Q) START AUTH</text>
<text x="164" y="788">Any AUTH IN LIST WE CAN USE?</text>
<text x="76" y="836">NO</text>
<text x="32" y="852">?</text>
<text x="180" y="852">UNABLE TO TALK (R)</text>
<text x="168" y="868">TO THIS SERVER!</text>
<text x="80" y="900">YES (S)</text>
<text x="304" y="900">(T)</text>
<text x="308" y="916">AUTH</text>
<text x="176" y="932">SENT CAPABILITY_PRE</text>
<text x="308" y="932">FAIL</text>
<text x="56" y="996">(U)</text>
<text x="280" y="996">(V)</text>
<text x="132" y="1012">AUTH</text>
<text x="36" y="1028">AUTH</text>
<text x="304" y="1028">OK?</text>
<text x="272" y="1060">(W)</text>
<text x="268" y="1076">AUTH</text>
<text x="268" y="1092">PASS</text>
<text x="88" y="1108">(X)</text>
<text x="36" y="1124">WAIT</text>
<text x="196" y="1140">SENT CAPABILITY_POST</text>
<text x="144" y="1188">(Y) CLIENT IS AUTHENTICATED</text>
</g>
</svg>
				</artwork>
			</artset>
		</figure>
	</section>
	<section>
		<name>Authenticating With Successful History</name>
		<t>
			When a client has had a successful connection to the server
			using the current client login name, then the client
			sends the AUTH command and appends as a second
			command in the same packet, the clients CAPABILITY_PRE command
			as shown in <xref target="AuthSummary01"/> (B &amp; C).
			Then the client waits for a server reply at
			<xref target="AuthSummary01"/> (I):
		</t>
		<t>
			When the server gets this dual command packet
			<xref target="AuthSummary01"/> at (D) and attempts the
			authentication process.
			If the authentication passes,[<xref target="AuthSummary01"/> (E)]:
			the server sends a	CAPABILITY_POST
			[<xref target="AuthSummary01"/> (G)]
			command to the client as the okay reply.
		</t>
		<t>
			If the authentication fails, then the server sends
			the client its first CAPABILITY_PRE command.
			[<xref target="AuthSummary01"/> (F)]
		</t>
		<t>
			The client waits for a reply from the server
			at <xref target="AuthSummary01"/> (I).
		</t>
		<t>
			When the client gets a CAPABILITY_PRE
			[<xref target="AuthSummary01"/> (F)]
			it knows the authentication failed, so the client
			goes to start a normal authentication
			process [<xref target="AuthSummary01"/> (K) &amp; (Q)]
		</t>
		<t>
			If the received command was a CAPABILITY_POST
			[<xref target="AuthSummary01"/> (G)], then
			the authentication passed and the client
			is authenticated.
			And starts any post authentication work.
			[<xref target="AuthSummary01"/> (J &amp; Y)]
		</t>

	</section>
	<section>
		<name>Authenticating With No History</name>
		<t>
			When there is not successful history between
			the client and server, the authentication
			process starts at 
			[<xref target="AuthSummary01"/> (M)]
			with the client sending its CAPABILITY_PRE
			command to the server.
			Then waits for a server reply
			[<xref target="AuthSummary01"/> (O)]
		</t>
		<t>
			As soon as the server gets its
			authentication CAPABILITY_PRE at
			[<xref target="AuthSummary01"/> (N)],
			the server evaluates the contents of
			the CAPABILITY_PRE from the client,
			matches it to the servers configured
			ability, and sends a CAPABILITY_PRE
			packet back to the client.
			[<xref target="AuthSummary01"/> (P)]
			This CAPABILITY_PRE packet contains
			the authentication method(s) that the
			client must use to authenticate with
			the server.
			A CAPABILITY_PRE command from the
			server is only sent after receiving
			one from the client.
			So the server only sends the common
			authentication method using a priority
			configured into the server.
		</t>
		<t>
			The servers CAPABILITY_PRE command
			may contain zero or more authentication
			methods.
			When more than one, all must be used.
			For example, the server could require
			a client certificate (AUTHCERT_TLS),
			and a user MD5 login (AUTHMD5).
			So both would be sent back, in this example.
			When the servers CAPABILITY_PRE command
			does not have any authentication methods,
			the server is telling the client that no
			authentication is possible.
			When this happens the server then terminates
			the connection.
			And the client then terminates the connection.
		</t>

	</section>

	<section>
		<name>Authentication Failure</name>
		<t>
			If the authentication fails, then the server replies
			back with a CAPABILITY_PRE with the sequence
			number the same as in the authentication request.
			And includes the supported authentication methods.
		</t>
		<t>
			After too many retries, the client or server may terminate the connection.
		</t>
		<figure>
			<name>AUTHCERT_USER</name>
			<artset>
				<artwork align="center" type="ascii-art"><![CDATA[
Failed authentication:

+---------------------------------+
| PacketHeader (Length:32)        |
+---------------------------------+
| Number of commands (Length:32)  |
+---------------------------------+
| Sequence (SEQ:32)               |
+-+-------------------------------+
|0| CAPABILITY_PRE (%x29:31)      |
+-+-------------------------------+
| ,,,
+----------------------------------
]]></artwork>
				<artwork align="center" type="svg">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="224" width="288" viewBox="0 0 288 224" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
<path d="M 8,48 L 8,208" fill="none" stroke="black"/>
<path d="M 24,144 L 24,176" fill="none" stroke="black"/>
<path d="M 280,48 L 280,176" fill="none" stroke="black"/>
<path d="M 8,48 L 280,48" fill="none" stroke="black"/>
<path d="M 8,80 L 280,80" fill="none" stroke="black"/>
<path d="M 8,112 L 280,112" fill="none" stroke="black"/>
<path d="M 8,144 L 280,144" fill="none" stroke="black"/>
<path d="M 8,176 L 280,176" fill="none" stroke="black"/>
<path d="M 8,208 L 280,208" fill="none" stroke="black"/>
<g class="text">
<text x="92" y="20">Failed authentication:</text>
<text x="116" y="68">PacketHeader (Length:32)</text>
<text x="140" y="100">Number of commands (Length:32)</text>
<text x="88" y="132">Sequence (SEQ:32)</text>
<text x="16" y="164">0</text>
<text x="132" y="164">CAPABILITY_PRE (%x29:31)</text>
<text x="32" y="196">,,,</text>
</g>
</svg>
				</artwork>
			</artset>
		</figure>
	</section>

</section>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->
<section anchor="AUTHANONYMOUS" xmlns:xi="http://www.w3.org/2001/XInclude">
	<name>Authentication - ANONYMOUS</name>
	<t>
		ANONYMOUS is both a capability and a command.
	</t>
	<section anchor="AUTHANONYMOUS-CAPABILITY">
		<name>Authentication - AUTHANONYMOUS - Capability</name>
		<t>
			When sent as a capability, a true or false value
			follows.
			When true, it means that anonymous login is supported.
			When false, it means that anonymous login is not supported.
		</t>
		<t>
			The highest bit is set to zero (0) which indicates
			this is a Phoenix defined capability, and
			not a vendor created and known capability.
			Followed by the 31-bit capability value.
		</t>
		<figure>
			<name>Capability - AUTHANONYMOUS</name>
			<artset>
				<artwork align="center" type="ascii-art" src="Drawings/ANONYMOUS-00.txt"/>
				<artwork align="center" type="svg" src="Generated/ANONYMOUS-00.svg"/>
			</artset>
		</figure>
	</section>

	<section anchor="AUTHANONYMOUS-COMMAND">
		<name>Authentication - AUTHANONYMOUS - Command</name>
		<t>
			Once the connection is made the client sends its CAPABILITY_PRE
			list, or an authentication to the server..
		</t>
		<t>
			If the client has already had a relationship with the server,
			then the client may send the AUTHANONYMOUS command to the server.
			And only if AUTHANONYMOUS	had been successful in the past, to that same server.
		</t>
		<t>
			If the server does not support (or no longer supports) an AUTHANONYMOUS
			command, it will reply with a CAPABILITY_PRE packet with
			the same sequence number the same as in the AUTHANONYMOUS login request.
			And include the authorized authentication methods.
		</t>
		<t>
			After the server receives an AUTHANONYMOUS, and if it supports it,
			it allows the connection and considers the user a valid
			anonymous user.
			Then the server replies with a CAPABILITY_POST command.
			When the client gets the CAPABILITY_POST command, it knows
			the AUTHANONYMOUS was successful.
			The client may then send any CAPABILITY_POST items to the server.
		</t>
			
		<figure>
			<name>AUTHANONYMOUS - Login Flow</name>
			<artset>
				<artwork align="center" type="ascii-art" src="Drawings/AnonFlow-00.txt"/>
				<artwork align="center" type="svg" src="Generated/AnonFlow-00.svg"/>
			</artset>
		</figure>

		<figure>
			<name>Capability - AUTHANONYMOUS</name>
			<artset>
				<artwork align="center" type="ascii-art" src="Drawings/ANONYMOUS-01.txt"/>
				<artwork align="center" type="svg" src="Generated/ANONYMOUS-01.svg"/>
			</artset>
		</figure>

		<section>
			<name>Authentication - ANONYMOUS - ABNF</name>
			<figure>
				<name>Authentication - ANONYMOUS - ABNF</name>
				<xi:include href="include/10-AuthAnonymous-ABNF.xml"/>
			</figure>
		</section>
		
		<section>
			<name>Authentication - ANONYMOUS - CBOR</name>
			<figure>
				<name>Authentication - ANONYMOUS - CBOR</name>
				<xi:include href="include/10-AuthAnonymous-XDR.xml"/>
			</figure>
		</section>
	</section>
	
</section>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->
<section xmlns:xi="http://www.w3.org/2001/XInclude">
	<name>Authentication - Certificate</name>
	<t>
		There are two kinds of AUTHCERT.
	</t>
	<ul>
		<li>
			Authentication by TLS certificate at connection time.
			This is called an AUTHCERT_TLS.
		</li>
		<li>
			Authentication challenge and response after connection time.
			This is called an AUTHCERT_USER. 
		</li>
	</ul>

	<section>
		<name>Authentication - Certificate - Capability</name>
		<t>
			When the server sends the AUTHCERT capability to the
			client, it is followed by two "enabled" values.
			One for AUTHCERT_TLS and the other for AUTHCERT_USER.
		</t>
		
	</section>

	<section>
		<name>AUTHCERT_TLS</name>
		<t>
			When the client connects to the server, it uses a
			pre authorized digital certificate for the TLS connection.
		</t>
		<t>
			The certificate itself could be sufficient.
			Or the server may look into the contents of the client
			public certificate supplied at TLS connection time
			for information to help it determine the level of trust,
			including none.
		</t>
		<t>
			The server could be configured to accept self-signed
			certificates, or it may be configured to verify
			a certificate chain to a root certificate it trusts.
			Or some combination.
		</t>
		<t>
			A server could be configured to only allow AUTHCERT_TLS
			from a subset of IP addresses or networks.
		</t>
		<t>
			When the client successfully authenticates using AUTHCERT_TLS,
			then the server replies with a CAPABILITY_POST
			command to the client. And no CAPABILITY_PRE
			command is sent by the server.
		</t>
		<t>
			When a client fails the AUTHCERT_TLS, then the
			server sends a CAPABILITY_PRE command	to the client.
			The client can then proceed with other authentication
			methods that were provided in the capability list supplied by
			the server.
		</t>
		<t>
			When a client gets a CAPABILITY_POST command from the
			server after connection, without having sent any
			authentication commands, the the client knows it has
			been authenticated with AUTHCERT_TLS.
		</t>
		<t>
			Clients expecting an AUTHCERT_TLS must wait for
			the CAPABILITY_POST or CAPABILITY_PRE command before
			continuing with client operations with associated
			folders and files.
		</t>
		<t>
			When a client that was not expecting an AUTHCERT_TLS
			gets a CAPABILITY_POST after connection
			and did not get a CAPABILITY_PRE, then the client know
			they are authenticated using the supplied TLS certificate.
		</t>
	</section>
	
	<section>
		<name>AUTHCERT_USER</name>
		<t>
			This authentication method still requires a valid TLS
			connection certificate, as it does with all connections.
			It also requires that the client send a public certificate
			to the server as a separate authentication step for the
			user.
		</t>
		<t>
			This type of login could be used when traveling or
			the server requires more control over security.
			The users certificates could be under the control
			of the users company, and easier to create and
			revoke than traditional certificate sources.
		</t>
		<t>
			In order for AUTHCERT_USER to work, the server MUST
			already have the users public certificate.
			This could have been setup by a servers implementation
			configuration files, or from a previous successful
			non-AUTHCERT_USER connection where the client informed
			the server of the users public certificate.
		</t>
		<t>
			To authenticate with a AUTHCERT_USER,
			the client sends a AUTHCERT_USER command with
			a clear text token over the TLS connection, followed by a
			the both the secret login name and password encrypted with
			the users private certificate.
		</t>
		<t>
			The token could be one time, or reusable.
			The server implementation is the authority on the token
			and token usage.
			It could be possible that the user never knows the
			actual login and password.
			They could be installed on a device for the user.
			They, perhaps, go to a web page, or other method to get the token.
			Then perhaps enter their personal password to allow
			access to the certificates and secret login information
			that is installed and already encrypted on the client.
		</t>
		<t>
			The server decrypts the users login name
			and password with the users public certificate
			selected from the clear text token sent.
		</t>
		<t>
			If the decrypted user login and password match
			what is expected, then the authentication is successful and
			the server replies with a CAPABILITY_POST
			command.
		</t>

	</section>

	<section>
		<name>Certificate Management</name>
		<t>
			A Phoenix server may use AUTHCERT_USER authentication.
			When it does, it needs a way for the user, if authorized
			to upload their public certificate to the server.
			This can be enabled or disabled by server configuration
			on the site, per user, or any other rules implemented
			in the server.
		</t>
		<t>
			User certificate management can only be used after
			the user has authenticated with the server.
		</t>
	</section>
</section>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->
<section anchor="AUTHMD5" xmlns:xi="http://www.w3.org/2001/XInclude">
	<name>Authentication - MD5</name>
	<t>
		AUTHMD5 is both a capability and a command.
	</t>
	<section anchor="AUTHMD5-CAPABILITY">
		<name>Authentication - MD5 - Capability</name>
		<t>
			When sent as a capability, a true or false value
			follows.
			When true, it means that AUTHMD5 is supported.
			When false, it means that AUTHMD5 is not supported.
		</t>
		<t>
			The highest bit is set to zero (0) which indicates
			this is a Phoenix defined capability, and
			not a vendor created and known capability.
			Followed by the 31-bit capability value.
		</t>
		<figure>
			<name>Capability - AUTHMD5</name>
			<artset>
				<artwork align="center" type="ascii-art" src="Drawings/MD5-00.txt"/>
				<artwork align="center" type="svg" src="Generated/MD5-00.svg"/>
			</artset>
		</figure>
	</section>

	<section anchor="AUTHMD5-COMMAND">
		<name>Authentication - MD5 - Command</name>
		<t>
			Once the connection is made the server sends its pre authentication
			capability list to the client.
			If AUTHMD5 is included in that list, then the client
			may initiate an AUTHMD5 login.
		</t>
		<t>
			If the client has already had a relationship with the server,
			then the client may send the AUTHMD5 command to the server
			before receiving the servers capability list, and only if AUTHMD5
			had been successful in the past, to that server.
		</t>
		<t>
			If the server does not support (or no longer supports) an MD5
			command, it will reply with a NotSupported packet with the
			sequence number	the same as in the MD5 login request.
		</t>
		<t>
			After the server receives an AUTHMD5, and if it supports it,
			then it attempts to verify the provided information.
			One of two replies are possible, success, or failure.
		</t>
		<t>
			On failure the server replies with a AUTHMD5 packet,
			with the sequence number the same that was in the
			AUTHMD5 command it received.
			With the login and password fields empty and their
			lengths set to zero.
		</t>
			<figure>
			<name>Capability - AUTHMD5</name>
			<artset>
				<artwork align="center" type="ascii-art" src="Drawings/MD5-01.txt"/>
				<artwork align="center" type="svg" src="Generated/MD5-01.svg"/>
			</artset>
		</figure>
		<t>
			On success the server replies with a post authentication
			capability command.
		</t>
			

		<section>
			<name>Authentication - MD5 - ABNF</name>
			<figure>
				<name>Authentication - MD5 - ABNF</name>
				<xi:include href="include/09-AuthMD5-ABNF.xml"/>
			</figure>
		</section>
		
		<section>
			<name>Authentication - MD5 - CBOR</name>
			<figure>
				<name>Authentication - MD5 - CBOR</name>
				<xi:include href="include/09-AuthMD5-XDR.xml"/>
			</figure>
		</section>
	</section>
	
</section>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->

<section anchor="CALENDAR_SUMMARY">
	<name>Calendar Commands Summary</name>
	<t>
		These command are based on iCalendar and iTIp.
	</t>
</section>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->

<section anchor="CAPABILITY"  xmlns:xi="http://www.w3.org/2001/XInclude">
	<name>Capability Commands Summary</name>
	<t>
		The purpose of this protocol is to facilitate the transfer
		of MIME objects, not to define how they are used.
		Capabilities allow each endpoint to ensure the other
		endpoint is capable of transferring the desired content
		and optionally allow control of the other endpoint.
	</t>
	<t>
		Capabilities are attributes of both a client and server
		implementation.
		Some may provide a superset or subset when compared
		to other implementations.
		This can be done to split workload or just because
		they specialize in specific operations.
	</t>
	<t>
		A capability is a 31-bit unsigned integer.
		Plus a 1-bit identifier signifying if it is a Phoenix capability
		or vendor specific capability, for a total of 32-bits.
	</t>
	<t>
		This specification describes several capabilities.
		Some are described in other sections, and some are
		described in this section.
		See the <xref target="CapabilityIndex">Capability Index</xref>
		for a complete list	in this specification.
	</t>
	<t>
		These are not a negotiation.
		Each sends their abilities to the other.
	</t>
	<t>
		Capabilities from the server are sent once or twice.
		Optionally one before the user is authenticated (CAPABILITY_PRE),
		and once after (CAPABILITY_POST).
		If a user logs out and stays connected, then the process starts
		over with the server assuming a new client just connected.
	</t>
	<t>
		Capabilities from the client may be sent, once, or twice
		per authentication process.
		The client sends a CAPABILITY_PRE with its connection to a server.
		And optionally once after the user is authenticated (CAPABILITY_POST).
	</t>
	<t>
		There is no requirement that a server provides
		an authentication method for any client.
		There is no requirement that a server provide
		any non-vendor capability for any client.
		They could be configured to only allow vendor
		specific authentication or only vendor specific commands because they
		are not servers open to the public and require
		non standard authentication methods,
		or only from clients providing a correct CAPABILITY_PRE
		value.
	</t>
	<t>
		<em>NOTE: Vendor specific capabilities MUST include a Length
		value after the capability value.
		This is because there is no way a non compatible implementation
		could calculate the length of the data that would follow it
		in order to find the next capability or command in the packet.
		</em>
	</t>

	<t>
		Table <xref target="PreAuthCap"/> lists some CAPABILITY_PRE
		capabilities.
	</t>

	<t>
		Some capabilities have data associated with them, others do not.
	</t>
	<section>
		<name>Capability - CAPABILITY_PRE</name>
		<t>
			Pre authentication capabilities are sent before authentication.
		</t>
		<t>
			When the client connects to a server it always sends a
			CAPABILITY_PRE as soon as the connection is established.
			This packet contains all of the authentication methods
			supported by the client.
			It is an ordered list with the most preferred at the start
			of the list and the lesser preferred at the end of the list.
		</t>
		<t>
			The CAPABILITY_PRE that the client sends to the server
			in this specification includes an optional VENDOR_ID.
			Vendors may add new client to server capabilities as long
			as they set the VENDOR_BIT in the command and are implemented
			to understand that not all server will understand their
			vendor specific extensions.
		</t>
		<t>
			xxx
		</t>
		<table anchor="PreAuthCap">
			<name>Capabilities - CAPABILITY_PRE</name>
			<thead>
				<tr>
					<th>Name</th>
					<th>Value</th>
					<th>Value Type</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>AUTHANONYMOUS</td>
					<td>%x26:31</td>
					<td></td>
					<td>
						<t>
							No authentication required.
							An example usage could be a shared company
							bulletin board where most employees had
							view only access to the messages.
							And perhaps the server only allowed
							company local IP addresses to use this
							authentication method.
						</t>
						<t>
						</t>
					</td>
				</tr>
				<tr>
					<td>AUTHMD5</td>
					<td>%x10:31</td>
					<td></td>
					<td>
						<t>
							Authenticate by providing an account name
							and an MD5 password.
						</t>
					</td>
				</tr>
				<tr>
					<td>AUTHCERT_TLS</td>
					<td>%x27:31</td>
					<td>
						CMD_e
					</td>
					<td>
						<t>
							Authenticate using the connections TLS certificate.
						</t>
					</td>
				</tr>
				<tr>
					<td>AUTHCERT_USER</td>
					<td>%x28:31</td>
					<td>
						CMD_e
					</td>
					<td>
						Like AUTHMD5, an account and password are provided
						in the payload and they are encrypted with a
						prearranged certificate.
						The server must already have the accounts public certificate.
					</td>
				</tr>
				<tr>
					<td>VENDOR_ID</td>
					<td>%x12:31</td>
					<td>string</td>
					<td>
						<t>
							VENDOR_ID includes a vendor ID
							string that can be used to help the server determine
							if it will send a post-authentication ADMIN capability
							or other vendor specific abilities.
						</t>
						<t>
							The specific string value is determined by the server
							implementation and is out of scope for this specification.
						</t>
					</td>
				</tr>
			</tbody>
		</table>
	</section>

	<section>
		<name>Capability - CAPABILITY_POST</name>
		<t>
			Table <xref target="PostAuthCap"/> lists the CAPABILITY_POST
			capabilities.
			Post-Authentication capabilities are sent to the client after a
			a user authenticates.
		</t>
		<t>
			A client or server may or might not also send an additional CAPABILITY_POST command
			as account permissions change.
		</t>
		<t>
			For example after authentication an administrator could give the
			current user more permissions.
			At that time the server would send a new CAPABILITY_POST to the client.
			Or perhaps the client needs to update the server with a new VENDOR_ID
			and CAPABILITY_POST after a license key is installed.
			Or perhaps remove capabilities after business hours.
		</t>

		<table anchor="PostAuthCap">
			<name>Capabilities - CAPABILITY_POST</name>
			<thead>
				<tr>
					<th>Name</th><th>Value</th><th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>x</td><td>x1</td><td>x2</td>
				</tr>
			</tbody>
		</table>
	</section>
</section>

<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->

<section anchor="EMAIL_SUMMARY">
	<name>EMail Commands Summary</name>
	<t>
		These commands allow for the fetching and submission
		of EMail messages
	</t>
</section>

<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->
<section anchor="FOLDERS">
	<name>File and Folder Commands Summary</name>
	<t>
		Remote systems have files and folders that are accessible.
		And have files and folders that are not accessible.
		This section covers only these files and folders for
		which the authenticated users has at least read only access
		to full access and control.
	</t>
	<t>
		Read only files and folders could be historical archives,
		news, email, calendar, or marketing information.
		Anything that the owner of the files and folders wants
		to share and keep unaltered.
	</t>
	<t>
		The file operations (FileOp) here are a descriptive category
		of several over the wire commands, there is no 'FileOp' command.
		Implementations are not required to support any or all of these
		commands.
	</t>
	<t>
		Folders might be nested.
		That is one folder may contain one or more folders.
		Each of which may contain folders.
		Much like a computer folder structure.
		Only folders and files that are read-only or are read-write
		are returned in a list to the client.
	</t>
	<t>
		Each file and folder has an ID.
		A FOLDER_LIST command returns a list of files and folders, each
		with their ID.
		Most FileOps use this ID and not the name.
		These IDs are guaranteed to not change during a session.
		The server should attempt to preserve IDs across sessions.
	</t>
	<table>
		<name>File and Folder Command List</name>
		<thead>
			<tr>
				<th>Op Name</th>
				<th>Value in hex</th>
				<th>Brief Description.
			</th></tr>
		</thead>
		<tbody>
			<tr>
				<td>
					FOLDER_CAPABILITY
					<br/>
					<xref target="FO_Cap"/>
				</td>
				<td>%x13</td>
				<td>
					<t>
						When sent as a command, request the list of
						folder commands supported.
					</t>
					<t>
						When FOLDER_CAPABILITY is sent as a reply,
						this includes a CBOR type 4 array of
						folder commands supported along with
						any of their optional or mandatory parameters.
					</t>
					<t>
						Only when an administrator changes the users
						access while a client is active will this
						list change during a session.
						The client will be notified of any changes.
						See <xref target="Notifications">Notifications</xref>.
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FOLDER_CREATE
					<br/>
					<xref target="FO_Create"/>
				</td>
				<td>%x14</td>
				<td>
					<t>
						Create a new folder.
						The reply will be success and folder ID, or a reason
						the creation was denied.
					</t>
					<t>
						Also the name of the capability for this permission.
						This indicates that user has the capability
						to create folders.
						It does not guarantee they can create a specific
						folder or folder hierarchy.
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FOLDER_COPY
					<br/>
					<xref target="FO_Copy"/>
				</td>
				<td>%x15</td>
				<td>
					<t>
						Copy a folder.
						The reply will be success or a reason
						the copy was denied.
					</t>
					<t>
						Also the name of the capability for this permission.
						This indicates that user has the capability
						to copy folders.
						It does not guarantee they can copy any specific
						folder to any specific location available to
						the user.
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FOLDER_DELETE
					<br/>
					<xref target="FO_Delete"/>					
				</td>
				<td>%x16</td>
				<td>
					<t>
						Delete a folder.
						The reply will be success and new folder ID, or a reason
						the delete was denied.
					</t>
					<t>
						Also the name of the capability for this permission.
						This indicates that user has the capability
						to delete folders.
						It does not guarantee they can delete all folders
						for which they have access 
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FOLDER_RENAME
					<br/>
					<xref target="FO_Rename"/>					
				</td>
				<td>%x17</td>
				<td>
					<t>
						Rename a folder.
						The reply will be success or a reason
						the rename was denied. The folder ID will not be changed.
					</t>
					<t>
						Also the name of the capability for this permission.
						This indicates that user has the capability
						to rename folders.
						It does not guarantee they can rename any specific
						folder for which the user has access.
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FOLDER_METADATA
					<br/>
					<xref target="FO_Meta"/>					
				</td>
				<td>%x18</td>
				<td>
					<t>
						Get, set, and update information associated with the
						folder by ID.
						The reply will be success and metadata permissions,
						or a reason	the operation was denied.
						All folders have a meta data object associated
						with them, and the list may be empty.
					</t>
					<t>
						Some file meta data is also returned with the FOLDER_OPEN
						command.
					</t>
					<t>
						This is not a CAPABILITY request or reply.
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FOLDER_MOVE
					<br/>
					<xref target="FO_Move"/>					
				</td>
				<td>%x19</td>
				<td>
					<t>
						Move a folder.
						The reply will be success or a reason
						the move was denied.
						The folder ID will not be changed.
					</t>
					<t>
						Also the name of the capability for this permission.
						This indicates that user has the capability
						to move folders.
						It does not guarantee they can move any specific
						folder for which the user has access.
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FOLDER_OPEN
					<br/>
					<xref target="FO_Open"/>
				</td>
				<td>%x1a</td>
				<td>
					<t>
						Open an existing folder and get information about the folder,
						its ID, and files in the folder.
						The reply will be success or a reason
						the open was denied.
					</t>
					<t>
						All users can open for at least read only access
						any folder they they were provided in a FOLDER_LIST
						reply.
						This is not a CAPABILITY reply or command.
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FOLDER_SHARE
					<br/>
					<xref target="FO_Share"/>
				</td>
				<td>%x1b</td>
				<td>
					<t>
						Share a folder.
						Share to a list or anyone.
					</t>
					<t>
						The reply will be a success or a reason
						the share was denied.
					</t>
					<t>
						Also the name of the capability for this permission.
						This indicates that user has the capability
						to share folders.
						It does not guarantee they can share any specific
						folder for which the user has access.
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FOLDER_LIST
					<br/>
					<xref target="FO_List"/>
				</td>
				<td>%x1c</td>
				<td>
					<t>
						List folders and optional files available to the user.
					</t>
					<t>
						The command may include zero or more folders ID's.
						The top most folder has no name, and is an
						empty string.
						The top most folder is the default folder name.
						SEE XREF-TODO.
					</t>
					<t>
						When provided, the reply includes a list of files
						within the folder.
						The content of each index entry depends
						on the type of file.
						SEE XREF-TODO.
					</t>
					<t>
						All clients may issue a FOLDER_LIST command.
						The result could be empty.
						This is not a CAPABILITY command or reply.
					</t>
					<t>
						Only shared folders have their contents altered
						during a session without the client initiating
						the changes.
						The client is notified of shared folder changes to
						folders and files at runtime that were not initiated
						by the client.
						See <xref target="Notifications"/>
					</t>
				</td>
			</tr>
			
			<tr>
				<td>
					FILE_CREATE
					<br/>
					<xref target="FI_Create"/>
				</td>
				<td>%x1d</td>
				<td>
					<t>
						Create a new file.
						The reply will be success and a new file ID, or a reason
						the create was denied.
					</t>
					<t>
						Also the name of the capability for this permission.
						This indicates that user has the capability
						to create files.
						It does not guarantee they can create any
						file for which they have folder access.
					</t>
				</td>
			</tr>

			<tr>
				<td>
					FILE_COPY
					<br/>
					<xref target="FI_Copy"/>
				</td>
				<td>%x1e</td>
				<td>
					<t>
						Copy a file.
						The reply will be success and the new file ID, or a reason
						the copy was denied.
					</t>
					<t>
						Also the name of the capability for this permission.
						This indicates that user has the capability
						to copy files.
						It does not guarantee they can copy any
						file for which they have folder access.
					</t>
				</td>
			</tr>

			<tr>
				<td>
					FILE_DELETE
					<br/>
					<xref target="FI_Delete"/>
				</td>
				<td>%x1f</td>
				<td>
					<t>
						Delete a file.
						The reply will be success or a reason
						the delete was denied.
					</t>
					<t>
						Also the name of the capability for this permission.
						This indicates that user has the capability
						to delete files.
						It does not guarantee they can delete any
						file for which they have folder access.
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FILE_RENAME
					<br/>
					<xref target="FI_Rename"/>
				</td>
				<td>%x20</td>
				<td>
					<t>
						Rename a file.
						The reply will be success or a reason
						the rename was denied.
						The file ID will not change.
					</t>
					<t>
						Also the name of the capability for this permission.
						This indicates that user has the capability
						to rename files.
						It does not guarantee they can rename any
						file for which they have folder access.
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FILE_METADATA
					<br/>
					<xref target="FI_Meta"/>
				</td>
				<td>%x21</td>
				<td>
					<t>
						Get, set, and update information associated with the
						file.
						The reply will be success or a reason
						the operation was denied.
						All files have a meta data object associated
						with them, and the list may be empty.
					</t>
					<t>
						Some file meta data is also returned with
						the FOLDER_OPEN	command.
					</t>
					<t>
						This is not a CAPABILITY request or reply.
						All users have access to the meta data
						for files they have access to.
						The list of meta data returned may be restricted
						depending on the authenticated user.
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FILE_MOVE
					<br/>
					<xref target="FI_Move"/>
				</td>
				<td>%x22</td>
				<td>
					<t>
						Move a file.
						The reply will be success or a reason
						the move was denied.
						The file ID will not change.
					</t>
					<t>
						Also the name of the capability for this permission.
						This indicates that user has the capability
						to move files.
						It does not guarantee they can move any
						file for which they have folder access.
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FILE_SHARE
					<br/>
					<xref target="FI_Share"/>
				</td>
				<td>%x23</td>
				<td>
					<t>
						Share a file.
						The reply will be success or a reason
						the share was denied.
					</t>
					<t>
						Also the name of the capability for this permission.
						This indicates that user has the capability
						to share files.
						It does not guarantee they can share any
						file for which they have folder access.
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FILE_GET
					<br/>
					<xref target="FI_Get"/>
				</td>
				<td>%x24</td>
				<td>
					<t>
						Get file contents.
					</t>
					<t>
						All files provided in FOLDER_LIST command
						are available to the client and may
						be read only.
					</t>
					<t>
						The reply will be the file contents, with
						optional index information for MIME objects.
						Or a reason for the failure.
					</t>
					<t>
						This is not a CAPABILITY request or reply.
						All users may get the file contents
						for any file provided to the in the FOLDER_LIST
						reply.
					</t>
				</td>
			</tr>
			<tr>
				<td>
					FILE_MODIFY
					<br/>
					<xref target="FI_Modify"/>
				</td>
				<td>%x25</td>
				<td>
					<t>
						Modify the contents of an existing file.
						The reply will be success or a reason
						the modify was denied.
					</t>
					<t>
						The reply will be a success with the contents
						updated, or a reason for the denial.
					</t>
					<t>
						All client may issue FILE_MODIFY commands.
						The contents of the folder index might
						have a read only attribute for any file.
						A user may not modify the contents
						of read only files.
					</t>
					<t>
						This is not a CAPABILITY request or reply.
					</t>
				</td>
			</tr>
		</tbody>
	</table>

	<section anchor="FO_Cap">
		<name>Folder - FOLDER_CAPABILITY</name>
		<t>
			As part of the successful authentication reply,
			the server sends the client a list
			of FileOps allowed by the client.
			This list includes zero or more folder
			capabilities the authenticated client
			is allowed to issue.
		</t>
		<t>
			The only time this list changes is if an administrator
			alters the authenticated client access while
			the session is active.
			The client will be notified of any changes.
			See <xref target="Notifications">Notifications</xref>.
			Unless the client receives such a notification,
			there is no need for the client to reissue
			a FOLDER_CAPABILITY request.
		</t>

		<section anchor="FO_Cap_Detail_CMD">
			<name>FOLDER_CAPABILITY Command (%x13) - Request</name>
			<t>
				A FOLDER_CAPABILITY request does not have any
				parameters.
				It is a request for all of the folder
				commands available to the authenticated user
			</t>

			<section anchor="FO_Cap_Detail_ABNF">
				<name>FOLDER_CAPABILITY Request ABNF</name>
				<t>
					This is transmitted as a CBOR major type 0, unsigned
					integer	with a hex value of %x13.
				</t>
				<xi:include href="include/FOLDER_CAPABILITY_REQUEST-ABNF.xml"/>
			</section>

			<section anchor="FO_Cap_Detail_Bits">
				<name>FOLDER_CAPABILITY Request Example</name>
				<t>
					A FOLDER_CAPABILITY request
					has the vendor bit set to zero.
					This is transmitted as a CBOR major type 0, unsigned
					integer	with a hex value of %x13.
					<xref target="FO_Cap_Detail_Bits_Figure"/> is a
					Phoenix packet payload content
					value for making a FOLDER_CAPABILITY request.
					This is in the payload part of a Phoenix packet.
				</t>
				<figure anchor="FO_Cap_Detail_Bits_Figure">
					<name>FOLDER_CAPABILITY over the wire</name>
					<artset>
						<artwork align="left" type="ascii-art" src="Drawings/FolderCapability-00.txt"/>
						<artwork align="left" type="svg" src="Generated/FolderCapability-00.svg"/>
					</artset>
				</figure>
			</section>
		</section>	
		<section anchor="FO_Cap_Detail_Reply">
			<name>FOLDER_CAPABILITY Reply (%x13)</name>
			<t>
				The reply is in a Phoenix packet reply
				payload.
				The reply is a CBOR major type 4 array.
				Each element of the array is a FOLDER_CAPABILITY
				with any optional or mandatory parameters.
			</t>
			<t>
				<xref target="F0_Cap_Detail_Reply_Bits"/>
				is an example of a session with only read-only access.
				In this example, the user can open folders,
				list folders, get the meta data for folders,
				get the metadata for files, and get files,
				and one vendor specific capability.
			</t>
			<figure anchor="F0_Cap_Detail_Reply_Bits">
				<xi:include href="Drawings/FolderCapability-Reply-00.txt"/>					
			</figure>
			<t>
				The example FOLDER_CAPABILITY reply
				in <xref target="F0_Cap_Detail_Reply_Bits"/> contains
				the folder commands the client may issue:
			</t>
			<artwork align="left" type="ascii-art">
ExampleCapabilityRepy
        = CBOR_FIXED_SIZE_ARRAY with 8 entries
          FOLDER_OPEN
          FOLDER_LIST
          FOLDER_METADATA FOLDER_METATDATA_PARAMETERS
          FILE_METADATA FILE_METADATA_PARAMETERS
          FILE_GET
          A VENDOR specific command
			</artwork>
<section anchor="FO_Cap_Reply_CBOR">
	<name>CBOR</name>
	<figure anchor="FO_Cap_Reply_CBOR_Figure">
		<name>CBOR Definition</name>
		<artwork align="left" type="ascii-art">
<![CDATA[
// The FOLDER_METADATA and FILE_METADATA
// capabilities return the OpPermissions
// allowed in the session.
//
// Four bits, each one set or not set.
// When the bit is set, the client
// is allowed to perform the operation
// on the meta data (or not when not set).
//
// NOTE: These are operations on the
// meta data, not the file or folder data.
//
BitMask:4 OpPermission {
 OpSetBitMask     = 0x01,
 OpGetBitMask     = 0x02,
 OpUpdateBitMask  = 0x04,
 OpDeleteBitMask  = 0x08
};

// Each entry in FOLDER_CAPABILITY reply is
// one of these enumerated REPLY values.
// 
enum FolderCapabilityReply_e {
  FOLDER_CREATE_REPLY = FOLDER_CREATE,
  FOLDER_COPY_REPLY = FOLDER_COPY,
  FOLDER_RENAME_REPLY = FOLDER_RENAME,
  FOLDER_METADATA_REPLY = FOLDER_METADATA,
  FOLDER_MOVE_REPLY = FOLDER_MOVE,
  FOLDER_OPEN_REPLY = FOLDER_OPEN,
  FOLDER_SHARE_REPLY = FOLDER_SHARE,
  FOLDER_LIST_REPLY = FOLDER_LIST,
  FILE_CREATE_REPLY = FILE_CREATE,
  FILE_COPY_REPLY = FILE_COPY,
  FILE_DELETE_REPLY = FILE_DELETE,
  FILE_RENAME_REPLY = FILE_RENAME,
  FILE_METADATA_REPLY = FILE_METADATA,
  FILE_MOVE_REPLY = FILE_MOVE,
  FILE_SHARE_REPLY = FILE_SHARE,
  FILE_GET_REPLY = FILE_GET,
  FILE_MODIFY_REPLY = FILE_MODIFY,
  VENDOR_FOLDER_REPLY = VENDOR_COMMAND
};

// In this version, each FOLDER CAPABILITY command REPLY
// has (1) no additional data (void), (2) or it
// has meta data permission values (OpPermissions).
//
union FolderCapabilityReplyEntry (FolderCapabiltyReply_e Cmd) {
  OpPermission  Permissions;
  void;
};

// The FOLDER_CAPABILITY reply:
// A variable list of capabilities in the reply.
// And is sent back as a CBOR major type 4 array.
//
struct FolderCapabilityReply
    FolderCapabilityReplyEntry Capabilities<>;
};

]]>	
		</artwork>
	</figure>
</section>
<section anchor="FO_Cap_Reply_Code">
<name>Code Example</name>
<sourcecode type="c++">
<![CDATA[
/**
 * Example code to extract the data and process
 * the FOLDER_CAPABILITY reply.
 */
 void
 ProcessFileFolderCapabilityReply(Session & Session,
                                  PhoenixPacket & Packet)
 {
   PhoenixPayload * Payload = Packet.GetPayload();

   // Default to no supported capabilities.
   //
   Session->DisableAllCapabilities();

   if (Payload != nullptr && Payload.size() > 0) {
     Capability                  * OneCapability;
     Capability::const_iterator    It;

     for (It = Payload->cbegin(); It != Payload->cend(); It++) {
       OneCapability = *It;

       if (VendorBitSet(OneCapability) {
         Session.AddVendorCapability(OneCapability)

       } else {
           switch (OneCapability->Name) {

           case FOLDER_CREATE:
             Session->CanCreateFolders(true);
             break;

           case FOLDER_COPY:
             Session->CanCopyFolders(true);
             break;

           case FOLDER_DELETE:
             Session->CanDeleteFolders(true);
             break;

           case FOLDER_RENAME:
             Session->CanRenameFolders(true);
             break;

           case FOLDER_METADATA:
             OpPermissions Allowed = OneCapability->GetOpPermissions());

             if (Allowed & OpSetBitMask) {
               Session->CanSetFolderMetaData(true);
             }
             if (Allowed & OpGetBitMask) {
               Session->CanGetFolderMetaData(true);
             }
             if (Allowed & OpUpdateBitMask) {
               Session->CanUpdateFolderMetaData(true);
             }
             if (Allowed & OpDeleteBitMask) {
               Session->CanDeleteFolderMetaData(true);
             }
             break;

           case FOLDER_MOVE:
             Session->CanMoveFolders(true);
             break;

           case FOLDER_OPEN:
             Session->CanOpenFolders(true);
             break;

           case FOLDER_SHARE:
             Session->CanShareFolders(true);
             break;

           case FOLDER_LIST:
             Session->CanListFolders(true);
             break;

           case FILE_CREATE:
             Session->CanCreateFiles(true);
             break;

           caes FILE_COPY:
             Session->CanCopyFiles(true);
             break;

           case FILE_DELETE:
             Session->CanDeleteFiles(true);
             break;

           case FILE_RENAME:
             Session->CanRenameFiles(true);
             break;

           case FILE_METADATA:
             OpPermissions Allowed = OneCapability->GetOpPermissions());

             if (Allowed & OpSetBitMask) {
               Session->CanSetFileMetaData(true);
             }
             if (Allowed & OpGetBitMask) {
               Session->CanGetFileMetaData(true);
             }
             if (Allowed & OpUpdateBitMask) {
               Session->CanUpdateFileMetaData(true);
             }
             if (Allowed & OpDeleteBitMask) {
               Session->CanDeleteFileMetaData(true);
             }
             break;

           case FILE_MOVE:
             Session->CanMoveFiles(true);
             break;

           case FILE_SHARE:
             Session->CanShareFiles(true);
             break;

           case FILE_GET:
             Session->CanGetFiles(true);
             break;

           case FILE_MODIFY
             Session->CanModifyFiles(true);
             break;

           default:
             ProcessError("Unknown FOLDER_CAPABILITY reply.");
             break;
       }
     }
   }
 }
]]>
</sourcecode>
</section>
		</section>
	</section>

	<section anchor="FO_Create">
		<name>File and Folder - FOLDER_CREATE</name>
	</section>

	<section anchor="FO_Copy">
		<name>File and Folder - FOLDER_COPY</name>
	</section>

	<section anchor="FO_Delete">
		<name>File and Folder - FOLDER_DELETE</name>
	</section>

	<section anchor="FO_Rename">
		<name>File and Folder - FOLDER_RENAME</name>
	</section>

	<section anchor="FO_Meta">
		<name>File and Folder - FOLDER_METADATA</name>
	</section>

	<section anchor="FO_Move">
		<name>File and Folder - FOLDER_MOVE</name>
	</section>

	<section anchor="FO_Open">
		<name>File and Folder - FOLDER_OPEN</name>
	</section>

	<section anchor="FO_List">
		<name>File and Folder - FOLDER_LIST</name>
		<t>
			When a client successfully authenticates,
			part of the success reply is a list of
			folders the client has access to.
		</t>
		<t>
			All changes to files, folder, or access
			not performed by the client will
			cause a notification to be sent to the client.
			(See <xref target="Notifications">Notifications</xref>)
		</t>
		<t>
			A FOLDER_LIST command returns an unordered array of File
			and Folder entries (FF entry).
			Each entry indicates if the item is a file or folder,
			its name, its ID (FFID), if it is shared with other users,
			any meta data, and if the user has read-only or read-write	access
		</t>
		<t>
			The meta data has two parts.
		</t>
		<ul>
			<li>
				Folder and File Meta data associated with the folder or file.
			</li>
			<li>
				User Meta data associated with the folder or file.
			</li>
		</ul>
		<t>
			Folder and File Meta data contains persistent information about
			the folder or file.
			Such as its size, index information, and other persistent
			information important to the application.
		</t>
		<t>
			User Meta data contains information about if the contents
			has been viewed and other application specific information
			unique to each user.
		</t>
		<t>
			The FOLDER_LIST command has optional parameters.
			The default is to get just the file and folder index (FF).
		</t>
		<ul>
			<li>The client can ask for meta data for folders.</li>
			<li>The client can ask for meta data for files.</li>
			<li>The client can ask MIME index information for files.</li>
		</ul>
		<section anchor="FF_Entry">
			<name>A File and Folder (FF) entry</name>
			<t>
				<![CDATA[
				FF = Name FFID Shared:1 RW:1

				string Name<>;
				uint64_t FFID;
				bits     Shared:1
				bits     RW:1
				]]>
				
			</t>
		</section>
		<section anchor="FolderListReply">
			<name>FOLDER_LIST - Reply</name>
		</section>
	</section>

	<section anchor="FO_Share">
		<name>File and Folder - FOLDER_SHARE</name>
	</section>

	<section anchor="FI_Create">
		<name>File and Folder - FILE_CREATE</name>
	</section>

	<section anchor="FI_Copy">
		<name>File and Folder - FILE_COPY</name>
	</section>

	<section anchor="FI_Delete">
		<name>File and Folder - FILE_DELETE</name>
	</section>

	<section anchor="FI_Rename">
		<name>File and Folder - FILE_RENAME</name>
	</section>

	<section anchor="FI_Meta">
		<name>File and Folder - FILE_METADATA</name>
	</section>

	<section anchor="FI_Modify">
		<name>File and Folder - FILE_MOVE</name>
	</section>

	<section anchor="FI_Move">
		<name>File and Folder - FILE_MOVE</name>
	</section>

	<section anchor="FI_Share">
		<name>File and Folder - FILE_SHARE</name>
	</section>

	<section anchor="FI_Get">
		<name>File and Folder - FILE_GET</name>
	</section>

</section>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->

<section anchor="KEEPALIVE_SUMMARY">
	<name>KeepAlive Command Summary</name>

	<t>
		The KeepAlive command is sent to the server from the client.
		It requests the server not time out.
		The server may honor or ignore the request.
	</t>
	<t>
		The Phoenix protocol is designed to transfer data and a server
		may handle a small subsets of what is possible.
		Which is why the server decides what is an important command
		while determining idle timeout.
	</t>
	<t>
		When the server sends the post authentication capabilities to the
		client, it includes an IdleTimeout capability that includes the
		number of seconds it allows for idle time.
		If no significant action has been taken by the client, as determined
		by the server, in that time	the server may timeout and close the connection.
	</t>
	<t>
		The KeepAlive command tells the server that the client wishes the
		server not to time out as long as a KeepAlive or other command
		is sent to the server before IdleTimeout seconds have passed.
	</t>
	<t>
		An IdleTimeout capability can be a positive number, zero, or
		a negative number.
	</t>
	<ul>
		<li>
			A positive number is the maximum idle time in seconds before the server
			terminates the connection.
		</li>
		<li>
			When the IdleTimeout is zero (0), the server does not timeout.
		</li>
		<li>
			When the IdleTimeout is less than zero (&lt; 0), it means it ignores
			KeepAlive and it will idle out in the absolute value of the IdleTimeout
			value in seconds.
			For example, a value of (-300) means it will ignore KeepAlive
			and timeout when the server determines nothing significant has
			happened in 5 minutes (300 seconds).
		</li>
	</ul>
	<t>
		Servers that are not threaded or can not reply to simultaneous
		or overlapping commands, MUST set their IdleTimeout to zero (0)
		or a negative number.
	</t>
	<t>
		Clients MUST NOT send KeepAlive commands to a server
		that has an IdleTimeout of zero (0) or negative (&lt; 0).
	</t>
	<t>
		Clients MUST NOT send KeepAlive commands to the server until
		at least 75% of the idle time has passed since the last
		command has been sent to the server.
	</t>
	<t>
		A server may terminate a connection if the server implementation
		determines that KeepAlive commands are arriving to quickly.
	</t>
</section>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->

<section anchor="PING_SUMMARY">
	<name>Ping Command Summary</name>

	<t>
		The ping command is only sent when the client implementation
		has determined it has waited too long for a command reply.
		The ping command is only initiated from the client.
		It is not valid for the server to send a ping command to a client.
	</t>
	<t>
		A ping command must not be sent before a successful authentication.
	</t>
	<t>
		The ping command MUST NOT be the first command sent to the server.
		It should only be sent when the client implementation determines
		it has waited too long for a reply.
	</t>
	<t>
		If the server supports the ping command, then a PING capability
		is sent in the CAPABILITY_POST command.
	</t>
	<t>
		Sometimes servers are unavailable and can go down.
		A server could be down for maintenance, or in a shutdown mode.
		It might limit the number of simultaneous connections.
		It might be very busy.
		The packets might not be making it to the server because of
		network issues.
	</t>
	<t>
		When a ping command is received by the server:
	</t>
	<ul>
		<li>
			When the server did not send PING capability in the
			post authentication capability list to the client.
			The server ignores the PING command.
		</li>
		<li>
			When the connection is not authenticated,
			The server ignores the PING command.
		</li>
		<li>
			When the client is authenticated,
			and when the server is available for processing commands.
			Then the server replies with a ping reply with the same sequence number.
			This could happen when the client implementation had determined it
			has waited too long	for an expected reply.
		</li>
	</ul>
	<t>
		If the server is alive and not available, the server
		will reply with a NotSupported command, with its sequence
		number set to the sequence number in the ping command.
	</t>
	<t>
		If a connected and authenticated client has been waiting for a reply
		or for some other reason needs to determine if the server is still
		available. It can send a ping command.
		If the server is still available, it sends a ping reply.
		If it is no longer available for any reason, it sends a NotSupported
		reply.
	</t>
	<t>
		A client MUST NOT send a ping command if it is waiting
		the results of a previously sent ping command.
		If the server is ignoring PING commands, a reply will
		never happen.
	</t>
	<t>
		A client MUST NOT send a ping command more frequently
		than 90% of the SERVER_TIMEOUT value that the server sent
		in the CAPABILITY_POST command.
	</t>
	<t>
		Servers must give priority to ping commands.
		If possible, reply as soon as it receives the command.
	</t>
	<t>
		With servers that support PING, clients MUST NOT send any other
		command while wating for the PING reply.
	</t>
	<t>
		The server MAY consider too many ping commands as a malfunctioning
		or malicious client and terminate the connection.
	</t>
	<t>
		Servers that are not threaded or can not reply to simultaneous
		or overlapping commands, MUST NOT include PING in
		their post authentication capability command.
	</t>
</section>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->

<section anchor="SMIME_SUMMARY">
	<name>S/MIME Commands Summary</name>
	<t>
		ToDo
	</t>
</section>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->
<section anchor="VendorID">
	<name>Command - VENDOR_ID</name>
	<t>
		When sent, the VENDOR_ID command is accompanied
		by a string.
		This string is unique and defined by the server implementation
		or instance.
	</t>
	<t>
		When a server gets a VENDOR_ID command, it compares
		it to what it expects.
		When they match, then after the user is authenticated
		the server can then determine if it will send 
		the SERVER_CONFIGURE capability to the client.
	</t>
	<t>
		It would be expected that any client sending its VENDOR_ID
		command to the server is expecting the possibility
		of receiving a SERVER_CONFIGURE capability back.
	</t>
	<t>
		The purpose of the VENDOR_ID command and its value
		is to help ensure that any SERVER_CONFIGURE commands
		are compatible between the client and server.
	</t>
	<t>
		Over the life of the connection, the VENDOR_ID command
		and value can change and would need to be sent again.
		It might update the value after authentication.
		Or after some action has been performed.
	</t>
	<t>
		For example, a server may perform one set of vendor specific operations
		during working hours, and a different set after hours.
		It may or might not also send an additional CAPABILITY_PRE command
		as account permissions change.
	</t>
</section>

</section>
<section>
	<name>Meta Data with Shared Objects</name>
	<t>
		When a server implementation allows shared objects,
		the meta data returned to the client may be different
		depending on the authenticated user.
		Some users may have read only copies, other may be
		able to delete the object.
	</t>
	<t>
		When a shared object is deleted, it is marked as deleted for
		only the user that issued the delete.
	</t>
	<t>
		When a shared object is expunged, its access is removed
		for the user that issued the expunge.
		After all users have expunged the object, then it is
		removed by the server.
	</t>
	<t>
		There are two kinds of expunge for shared objects.
		Forced and Delayed.
	</t>
	<t>
		Server implementations must reject attempts to fetch or view
		a folder or file or any of its meta data when an expunge has started,
		and not yet completed.
	</t>
	<ul>
		<li>
			<t>
				Forced:
			</t>
			<t>
				A forced expunge can be the result of security policies
				at the server, site, or administrators discretion.
				This also is how timed messages are deleted.
			</t>
			<t>
				In order for a shared object that is expunged to not
				force an immediate re-index for all clients, when
				the server gets a forced expunge, the server sends
				an expunge to all clients, where the client MUST immediately make
				the object not show	to the user and MUST invalidate
				any file, cached, or memory copy of the data the client
				has control over.
				Then when convenient, the client can do a re-index
				of the folder.
				When a user is viewing the object when an expunge
				arrives, the client must inform the user that the data
				is no longer available and replace the user view of
				the data with an empty object or move the view to
				another object.
			</t>
			<t>
				Server implementations must prioritize forced expunge notices
				to the clients and immediately reject all attempts to read,
				view, copy, or access meta data.
			</t>
		</li>
		<li>
			<t>
				Delayed:
			</t>
			<t>
				The user is informed the MIME object is no longer available.
				The client implementation may continue to show the object.
				The client may copy the MIME object, unless tagged as
				NoCopy.
			</t>
			<t>
				The next time the client does an expunge the object will be
				expunged from the client.
			</t>
			<t>
				When a client application closes, all delayed expunges
				MUST occur at exit.
			</t>
			<t>
				When a client applications starts the client MUST check for
				delayed expunges that have not been processed and expunge them
				and not	allow the user to see them.
			</t>
		</li>
	</ul>
</section>
<section anchor="Notifications">
	<name>Notifications</name>
	<t>
		TODO
	</t>
</section>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->

<section anchor="META_DATA" xmlns:xi="http://www.w3.org/2001/XInclude">
	<name>Meta Data</name>
	<t>
		In this specification a file and a MIME object are used
		interchangeably.
		Meta Data is data that is associated with the MIME object
		and not contained within the MIME object.
		Meta Data should never be stored in the MIME object as altering
		the MIME object would invalidate the index information and
		can invalidate digital signature and encryption information.
	</t>
	<t>
		Meta Data for the folder and MIME objects is returned in
		a FOLDER_OPEN, FILE_OPEN, FILE_METADATA, or FOLDER_METADATA command.
		Meta Data can be set and updated by the client using FILE_METADATA
		or FOLDER_METADATA commands.
	</t>
	<t>
		Most are 8-bit boolean values that are set to false (%x00) or true (%x01).
		A value that does not exists is the same as a false.
	</t>
	<t>
		Meta data can be global to the object.
		That is once tagged (or not tagged) the attribute shows up for all
		users.
		Or it can be user specific meta data.
		User specific meta data does not show up for other users.
	</t>
	<t>
		Many have the same or similar name and meaning as they do
		in <xref target="RFC9051">IMAP</xref>.
	</t>

	<section>
		<name>Meta Data - Answered</name>
		<t>
			This Meta Data only applies to files.
		</t>
		<t>
			When true, the object has been replied to by the client.
			This has the same meaning as \Answered does in IMAP.
		</t>
		<t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
	</section>
	
	<section>
		<name>Meta Data - Attributes</name>
		<t>
			This object has been tagged with special attributes.
			It is a list of strings with matching values.
		</t>
		<t>
			User defined attributes MUST start with "X-".
			These are not portable between implementations
			and no attempt should be made to copy these
			between implementations.
		</t>
		<t>
			Non user defined attributes are described
			in other sections or specifications.
		</t>
		<t>
			This can be user specific meta data or global meta data.
			See the specific attribute documentation.
		</t>
	</section>
	
	<section>
		<name>Meta Data - Deleted</name>
		<t>
			When true, this object has been marked as deleted
			and has not yet been expunged.
			This has the same meaning as \Deleted does in IMAP.
		</t>
		<t>
			For shared objects, an expunge removes the
			user from shared access to the file.
			And the actual expunge is only processed
			when all shared users have expunged
			the object.
		</t>
		<t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
	</section>
	
	<section>
		<name>Meta Data - Draft</name>
		<t>
			This Meta Data only applies to files.
		</t>
		<t>
			When true, this object is incomplete and not ready.
		</t>
		<t>
			This has the same meaning as \Draft does in IMAP.
		</t>
		<t>
			This value can be set and unset.
			This is user specific meta data.
		</t>
	</section>
	
	<section>
		<name>Meta Data - Flagged</name>
		<t>
			An object has been tagged as important.
			This is the same as the IMAP \Flagged value. 
		</t>
		<t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
	</section>

	<section>
		<name>Meta Data - Forwarded</name>
		<t>
			This Meta Data only applies to files.
		</t>
		<t>
			This has the same meaning as $Forwarded does in IMAP.
		</t>
		<t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
	</section>

	<section>
		<name>Meta Data - Hide</name>
		<t>
			With NotExpungable objects, the user may wish to not view the object.
			In these cases the attribute Hide can be set.
			The attribute does not effect the view of other users.
		</t>
		<t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
	</section>
	
	<section>
		<name>Meta Data - Junk</name>
		<t>
			This has the same meaning as $Junk does in IMAP.
		</t>
		<t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
	</section>
	
	<section>
		<name>Meta Data - MDNSent</name>
		<t>
			This Meta Data only applies to files.
		</t>
		<t>
			This value can be set and unset.
			This has the same meaning as $MDNSent does in IMAP.
		</t>
		<t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
	</section>

	<section>
		<name>Meta Data - NoCopy</name>
		<t>
			When true, this MIME object can not be copied.
		</t>
		<t>
			This value can be set and unset by the owner of the file or folder.
			This value can not be unset by non owners.
			This is global meta data.
		</t>
		<t>
			User interfaces MUST NOT allow the MIME object to be copied.
			They MUST disable any copy/paste for the object in the user interface.
			The user interface may elect to display an indicator to the user that
			what they are viewing is read only.
		</t>
	</section>
	
	<section>
		<name>Meta Data - NotJunk</name>
		<t>
			This has the same meaning as $NotJunk does in IMAP.
		</t>
		<t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
	</section>
	
	<section>
		<name>Meta Data - NotExpungable</name>
		<t>
			The mime object can not be marked for delete or expunged.
			It could be because it is an historical record that will never
			be expunged, or other reason.
		</t>
		<t>
			A client implementation could use the Hide attribute
			to not show the object to the user.
		</t>
		<t>
			This value can be set and unset by the owner of the file or folder.
			This value can not be unset by non owners.
			This is global meta data.
		</t>
	</section>
	
	<section>
		<name>Meta Data - Phishing</name>
		<t>
			This has the same meaning as $Phishing does in IMAP.
		</t>
		<t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
	</section>
	
	<section>
		<name>Meta Data - ReadOnly</name>
		<t>
			The MIME object associated with this attribute
			can not be altered, deleted, moved, or renamed.
			It can be copied, unless the NoCopy meta tag
			is also applied.
		</t>
		<t>
			This value can be set and unset by the owner of the file or folder.
			This value can not be unset by non owners.
			This is global meta data.
		</t>
		<t>
			Setting of this to false may fail if the file or folder is
			stored on read-only media.
			When the file or folder is stored on read-only media,
			this MUST BE set to true.
		</t>
	</section>
	
	<section>
		<name>Meta Data - Shared</name>
		<t>
			The MIME object associated with this attribute
			is shared and is also often tagged with the ReadOnly
			meta data tag.
		</t>
		<t>
			This value can not be set and unset by the owner.
		</t>
		<t>
			If copying of the file or folder is allowed, then
			the shared attribute is removed when copied.
		</t>
		<t>
			This file or folder will only be expunged when all
			of the users with shared access have deleted and
			expunged it.
		</t>
	</section>
	
	<section>
		<name>Meta Data - Seen</name>
		<t>
			This has the same meaning as \Seen does in IMAP.
		</t>
		<t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
	</section>
	
	<section>
		<name>Meta Data - MDNData Attribute</name>
		<t>
			This Meta Data Attribute is only visible to the
			owner of the object for which MDN has been set.
		</t>
		<t>
			This is a list of recipients email address that
			that are on the distribution list effected by the MDN.
		</t>
		<section>
			<name>MDNRecord</name>
			<t>
				The format of an MDNRecord:
			</t>
			<table>
				<thead>
					<tr>
						<td>Name</td><td>CBOR Type</td><td>Description</td>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>MDNSent</td><td>uint64_t</td>
						<td>
							The UTC timestamp as a 64-bit unsigned integer
							in network byte order of when the MDN reply was sent.
						</td>
					</tr>
					<tr>
						<td>MDNListCount</td><td>uint32_t</td>
						<td>
							A 32-bit unsigned integer in network byte order
							indicating how many were on the distribution list
							for this MDN.
						</td>
					</tr>
				</tbody>
			</table>
			<figure anchor="MDNData" align="center">
				<name>MDNRecord</name>
				<artset>
					<artwork align="center" type="ascii-art" src="Drawings/MDN-00.txt"/>
					<artwork align="center" type="svg" src="Generated/MDN-00.svg"/>
				</artset>
			</figure>
			<section>
				<name>MDNRecord - ABNF</name>
				<t>
					ABNF:
				</t>
				<xi:include href="include/07-MDNRecord-ABNF.xml"/>
			</section>
			<section>
				<name>MDNRecord - CBOR</name>
				<t>
					CBOR:
				</t>
				<xi:include href="include/07-MDNRecord-ABNF.xml"/>
				<t>
					Followed by MDNListCount MDNEntry's.
				</t>
			</section>
		</section>
		<section>
			<name>MDNEntry</name>
			<table>
				<name>MDMEntry ABNF/CBOR Mapping</name>
				<thead>
					<tr>
						<td>Name</td><td>CBOR Type</td><td>Description</td>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>UTC</td><td>uint32_t</td>
						<td>
							The UTC timestamp as a 64-bit unsigned integer
							in network byte order of when the MDN reply was received.
							Set to zero if not received.
						</td>
					</tr>
					<tr>
						<td>EMail Length</td><td>uint32_t</td>
						<td>
							The number of octets in the email address that follows.
							Not including any terminating zero.
						</td>
					</tr>
					<tr>
						<td>EMailAddress</td><td>string</td>
						<td>
							A string of the associated
							email address of the user that has or has not returned
							the MDN.
						</td>
					</tr>
				</tbody>
			</table>
			<figure anchor="MDNRecord" align="center">
				<name>MDNEntry</name>
				<artset>
					<artwork align="center" type="ascii-art" src="Drawings/MDN-01.txt"/>
					<artwork align="center" type="svg" src="Generated/MDN-01.svg"/>
				</artset>
			</figure>
			<section>
				<name>MDNEntry ABNF</name>
				<t>
					ABNF:
				</t>
				<figure>
					<name>MDNEntry - ABNF</name>
					<xi:include href="include/08-MDNEntry-ABNF.xml"/>
				</figure>
			</section>
			<section>
				<name>MDNEntry - CBOR</name>
				<t>
					CBOR:
				</t>
				<figure>
					<name>MDNEntry - CBOR</name>
					<xi:include href="include/08-MDNEntry-XDR.xml"/>
				</figure>
			</section>
		</section>
	</section>
</section>
		<xi:include href="Index.xml"/>
		<xi:include href="IANA.xml"/>
    <xi:include href="SecurityConsiderations.xml"/>
    <!-- NOTE: The Acknowledgements and Contributors sections are at the end of this template -->
  </middle>

  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        
        <xi:include href="References/reference.RFC.0822.xml"/>
        <xi:include href="References/reference.RFC.2119.xml"/>
        <xi:include href="References/reference.RFC.4506.xml"/>
        <xi:include href="References/reference.RFC.5234.xml"/>
        <xi:include href="References/reference.RFC.8174.xml"/>
        <xi:include href="References/reference.RFC.8446.xml"/>
        <xi:include href="References/reference.RFC.8949.xml"/>
        <xi:include href="References/reference.RFC.9051.xml"/>
        <xi:include href="References/reference.POSIX.xml"/>
      </references>
 
      <references>
        <name>Informative References</name>
					<reference anchor="PhoenixImplementation" target="https://github.com/RiverExplorer/Phoenix">
					<front>
						<title>Phoenix Sample Implementation</title>
						<author initials="D." surname="Royer" fullname="D. Royer"/>
						<date year="2025"/>
						<abstract>
							<t>
								A sample Phoenix implentation.
								<xref target="PhoenixImplementation"/>
							</t>
						</abstract>
					</front>
					</reference>
      </references>
    </references>
    <xi:include href="AdminBinaryValues.xml"/>
    <xi:include href="AuthBinaryValues.xml"/>
    <xi:include href="CapabilityIndex.xml"/>
    <xi:include href="FileBinaryValues.xml"/>
    <xi:include href="ProtocolBinaryValues.xml"/>
    <xi:include href="ALL-ABNF.xml"/>
    <xi:include href="ALL-XDR.xml"/>

    <section anchor="Acknowledgements" numbered="false">
      <!-- [REPLACE/DELETE] an Acknowledgements section is optional -->
      <name>Acknowledgments</name>
      <t></t>
    </section>
    
    <section anchor="Contributors" numbered="false">
      <!-- [REPLACE/DELETE] a Contributors section is optional -->
      <name>Contributors</name>
      <t>Thanks to all of the contributors. [REPLACE]</t>
      <!-- [CHECK] it is optional to add a <contact> record for some or all contributors -->
    </section>
    
 </back>
</rfc>
