<?xml version="1.0" encoding="utf-8"?>
<?xml-model href="rfc7991bis.rnc"?>
<!DOCTYPE rfc [
<!ENTITY nbsp "&#160;">
<!ENTITY zwsp "&#8203;">
<!ENTITY nbhy "&#8209;">
<!ENTITY wj "&#8288;">
]>
<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="info" docName="draft-royer-phoenix-00" ipr="trust200902" obsoletes="" updates="" submissionType="IETF" xml:lang="en" version="3">
  <front>
    <title abbrev="Phoenix: Lemonade Risen Again">Phoenix: Lemonade Risen Again</title>
    <seriesInfo name="Internet-Draft" value="draft-royer-phoenix-00"/>
    <author fullname="Doug Royer" initials="DM" surname="Royer">
      <organization>RiverExplorer Games LLC</organization>
      <address>
        <postal>
          <!-- Reorder these if your country does things differently -->
          <street>848 N. Rainbow Blvd #1120</street>
          <city>Las Vegas</city>
          <region>Nevada</region>
          <code>89107</code>
          <country>US</country>
          <!-- Uses two letter country code -->
        </postal>
        <phone>1+714-989-6135</phone>
        <email>DouglasRoyer@gmail.com</email>
        <!-- Can have more than one <email> element -->
        <uri>https://RiverExplorer.games</uri>
      </address>
    </author>
    <date year="2025"/>
    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>imap</keyword>
    <keyword>pop</keyword>
    <keyword>smtp</keyword>
    <keyword>mime</keyword>
    <keyword>lemonade</keyword>
    <keyword>phoenix</keyword>
    <abstract>
      <t>
	NOTE: This is just getting started, not ready for submission yet.
</t>
      <t>
	Email and MIME messages account for one the largest volumes of data on the
	internet.
	The transfer of these MIME message has not had a major updated in decades.
	Part of the reason is that it is very important data and altering it
	takes a great deal of care and planning.
</t>
      <t>
	This application transport can also transfer non-MIME data.
	It can be used as an XDR transport, or for opaue data (blobs of
	known or unknown data) transport.
</t>
      <t>
	Another major concern is security and authentication.
	This proposal allows for existing autnentication to continue to work.
</t>
      <t>
	This is a MIME message transport that can facilitate
	the transfer of any kind of MIME message. Including email, calendaring,
	and text, image, or multimedia MIME messages.
	It can transfer multipart and simple MIME messages.
</t>
      <t>
	The POP and IMAP protocols are overly chatty and now that the Internet
	can handle 8-bit transfers, there is no need for the overly complex
	text handling of messages.
</t>
      <t>
	This proposal includes a sample implementation.
	(<eref target="https://github.com/RiverExplorer/Phoenix"/>)
	Which also includes a gateway from this proposal to existing system.
	Thunderbid and Outlook plugins are part of the sample implementation.
</t>
    </abstract>
  </front>
  <middle>
    <section>
      <name>Requirements Language</name>
      <t>
		The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
		"SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
		RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
		interpreted as described in BCP 14 <xref target="RFC2119"/>
		<xref target="RFC8174"/> when, and only when, they appear in
		all capitals, as shown here.
	</t>
    </section>
    <section>
      <name>ABNF Notes and Some Definitions</name>
      <section>
        <name>ABNF Number of bits in value</name>
        <t>
			This specification adds some usage to <xref target="RFC5234">ABNF</xref>
			to deal with bit width in a binary number.
		</t>
        <t>
			Terminals may specify a bit width.
			That is the number of bits in the value.
		</t>
        <t><xref target="RFC5234" section="2.3">Terminal Values</xref>
			is within this specification defined to be:
		</t>
        <t>
			b = binary / binary:width
			<br/>
			<br/>
			d = decimal / decimal:width
			<br/>
			<br/>
			x = hexadecimal / hexadecimal:width
		</t>
        <t>
			Where: with is the number of bits in the value.
			And must be an unsigned integer greater than zero.
		</t>
        <t>
			And they will pack when applied to to a rule:
		</t>
        <t>
			When the left side has a width: 
			The number of bits on the left side must equal
			the number of bits on the right side.
		</t>
        <t>
			In this example A Header is 32-bits in size
			and is composed of an 8-bit and 24-bit value.
			The most significant value are placed on the left of the rule:
		</t>
        <artwork type="abnf" name="" align="left" alt=""><![CDATA[
Header:32 = Offset:8 Length:24
]]></artwork>
        <t>
		</t>
        <t>
			The pseudo code could be:
		</t>
        <sourcecode>

// Header is a 32-bit unsigned integer.
// Offset is an 8-bit unsigned integer.
// Length is a 24-bit unsigned integer
//
Header = Offset &lt;&lt; 24 | Length;

		</sourcecode>
        <t>
			This shifts the 8-bit Offset over 24 bits to the left, then
			adds the 24-bit Length.

			The result would be:
		</t>
        <figure anchor="ABNF-00" align="center">
          <name>Packed Bit Example</name>
          <artset>
            <artwork type="ascii-art" src="ABNF-00.txt"/>
            <artwork type="svg" src="ABNF-00.svg"/>
          </artset>
        </figure>
      </section>
      <section>
        <name>Some ABNF Definitions</name>
        <artwork type="abnf" name="" align="center" alt=""><![CDATA[

             ; An 8-bit unsigned integer
uint8_t    = 0x00 - 0xff
		
             ; A 16-bit unsigned integer
uint16_t   = 0x0000 - 0xffff

             ; A 32-bit unsigned integer
uint32_t   = 0x00000000 - 0xffffffff

             ; A 64-bit unsigned integer
uint64_t   = 0x0000000000000000 - 0xffffffffffffffff

]]></artwork>
        <table>
          <thead>
            <tr>
              <td>
						ABNF TYPE
					</td>
              <td>
						XDR TYPE
					</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
						uint8_t
					</td>
              <td>
						uint8_t
					</td>
            </tr>
            <tr>
              <td>
						uint16_t
					</td>
              <td>
						uint16_t
					</td>
            </tr>
            <tr>
              <td>
						uint32_t
					</td>
              <td>
						uint32_t
					</td>
            </tr>
            <tr>
              <td>
						uint64_t
					</td>
              <td>
						uint64_t
					</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section xmlns:xi="http://www.w3.org/2001/XInclude">
      <name>Introduction</name>
      <t>
		On the Internet, just about everything is a MIME object and there are
		many ways to transport MIME.
		This document specifies a new application level MIME transport mechanism
		and protocol.
		This document does not specify any new or changed MIME types.
	</t>
      <t>
		Transporting MIME objects is generally done in one of two ways:
		(1) Broadcasting, (2) Polling.
		Both methods often require some form of authentication, registration,
		and selecting of the desired material.
		These selection processes are essentially a form of remote folder management.
		In some cases you can only select what is provided, and in others
		you have some or a lot of control over the remote folders.
	</t>
      <t>
		In addition to other functions, this specification defines a remote
		and local folder management.
		This remote folder management is common with many type of very popular
		protocols.
		This design started by looking at the very popular IMAP and POP protocols.
	</t>
      <t>
		An additional task is transporting the perhaps very large MIME objects.
		Some MIME objects are so large that some devices may 
		default to looking at only at parts of the MIME object.
		An example is an email message with one or more very large attachments, where
		the device may default to not download the large attachment without a
		specific request from the user.
	</t>
      <t>
		Some objects are transported as blocks of data with a known and fixed size.
		These are often transported with some kind of search, get, and put commands.
		In effect these are folder and file commands
	</t>
      <t>	
		Other MIME objects are transported in streams of data with an unspecified
		size,	such as streaming music, audio, or video.
		This specification describes how to use existing protocols to 
		facilitate the data streaming.
		And again, these are folder and file commands.
	</t>
      <t>
		A MIME object can be a simple object, or it may contain many multipart
		sections of small to huge size.
		These sections can be viewed as files in the containing MIME object.
	</t>
      <t>
		By implementing this specification application developers can
		use the techniques to manage local and remote files and folders.
		Remote email or files are the same thing in this specification.
		The sections of MIME object with multipart sections are viewed as files
		in the MIME object.
		You can interact with the entire folder, or just the files within it.
	</t>
      <t>
		MIME objects have meta data, and they are called headers.
		Files and folders have meta data, and they are called file attributes.
		This specification does not mandate any meta data.
		It does define some that may be used by implementations.
		Other related specifications do define some meta data
		that is consistant with existing protocols.
		This protocol allows for	a consistent transport of existing meta data
		and MIME objects.
	</t>
      <t>
		File and folder meta data is a complex task that can involve
		access control lists and permissions.
		This specification defines a mechanism to transport this meta data,
		it does not define the meta data.
	</t>
      <t>
		And this specification provides for the ability to define both
		protocol extensions and the creating of finer control for specific
		commands that may evolve over time.
	</t>
      <t>
		This examples compares current folder and file manipulations
		to how it can be used in this protocol with email.
	</t>
      <ul>
        <li>
			You can search for file names.
			You can search email for: sender, subject, and more.
		</li>
        <li>
			You can search for file contents.
			You can search for email message contents.
		</li>
        <li>
			You can create, delete, and modify files.
			You can create, delete, and modify email messages.
		</li>
        <li>
			You can create, delete, and modify folders.
			You can create, delete, and modify email folders.
		</li>
      </ul>
      <t>
		What this specification defines:
	</t>
      <ul>
        <li>
			How to use existing authentication implementations or use new ones.
		</li>
        <li>
			This specification describes a standard way to perform file
			and folder operations	that are remote to the application and
			agnostic to purpose of data being transported.
		</li>
        <li>
			Specifies a way to migrate from some existing protocols to Phoenix.
			Provides links to sample implementations.
		</li>
      </ul>
    </section>
    <section>
      <name>Terms and Definition used in this proposal</name>
      <t>
		The following is a list of terms with their definitions as
		used in this specification.
	</t>
      <dl newline="true">
        <!-- Omit newline="true" if you want each definition to start on the sa\
				 me line as the corresponding term -->
        <dt>AdminCmd</dt>
        <dd>
			A general term for any administrative command.
			Administrative and auditing operations.
			This list includes commands for authorized users to configure,
			query logs, errors,	possibly user activity.
		</dd>
        <dt>AuthCmd</dt>
        <dd>
			A general term for any authentication command.
			Authentication and authorization operations.
			These operations authenticate users and verity their authorization
			access.
		</dd>
        <dt>Body Part ID (BPID)</dt>
        <dd>
          <t>
				A unique ID for a MIME Object.
				This is an unsigned 32-bit integer in network byte order
				that is assigned by the server and sent to the client
				on a successful folder open.
				This ID persists across connections.
				And as long as the MIME object does not get altered in any way,
				this ID is valid and persists across servers.
				It is the offset in octets from the beginning of the
				message to the start of the body part.
			</t>
          <t>
            <xref target="Index-Ref">See Index.</xref>
          </t>
        </dd>
        <dt>Command (CMD)</dt>
        <dd>
			A specific protocol operation, or command.
			They are broken down into, AdminCmd, AuthCmd, FileCmd,
			and ProtoCmd.
			These are called a CMD or command.
		</dd>
        <dt>FileCmd</dt>
        <dd>
			A general term for any file or folder command.
			This include creating, getting, modifying, deleting, moving,
			and renaming files.
		</dd>
        <dt>Folder ID (FolderID)</dt>
        <dd>
          <t>
				A unique ID for a MIME folder.
				This is an unsigned 32-bit integer in network byte order
				that is assigned by the server and sent to the client
				on a successful folder open.
				This ID persists across connections to the same server.
				Once a folder has an ID, it never changes on a server
				as described in <xref target="FOLDERS">Folders</xref>.
			</t>
          <t>
            <xref target="Index-Ref">See Index.</xref>
          </t>
        </dd>
        <dt>Index Operation Type (IndexOP)</dt>
        <dd>
          <t>
				Header Index Operation.
				A command sent as part of a folder open command that tells the
				server which MIME headers it would like indexed.
			</t>
          <t>
            <xref target="Index-Ref">See Index.</xref>
          </t>
        </dd>
        <dt anchor="HeaderDefID">Header Name ID (HID)</dt>
        <dd>
          <t>
				And 8-bit unsigned integer the client has assiged to
				a specific header name.
				The client and server use the ID rather than passing
				the string value back and forth in indexes and other
				operations.
				It is not used in the MIME object.
			</t>
          <t>
            <xref target="Index-Ref">See Index.</xref>
          </t>
        </dd>
        <dt anchor="Header822">HeaderName822</dt>
        <dd>
			A RFC822 or MIME header name.
			See <xref target="RFC0822" section="3.2"/>
		</dd>
        <dt anchor="HeaderOffset">HeaderID</dt>
        <dd>
          <t>
				An offset into a MIME object where a specific header starts.
				As its position in a MIME object is unique, this value
				is also used as the offset to a specific header.
				As long as the MIME object does not change in any way
				this HeaderID persisists across connections and servers.
			</t>
          <t>
            <xref target="Index-Ref">See Index.</xref>
          </t>
        </dd>
        <dt anchor="Index-HVH">Header Value ID (HVID)</dt>
        <dd>
          <t>
				Related to Header ID.
				An offset into a MIME object where a specific header value starts.
				As the position in a MIME object is unique, this value
				is also used as the HVID to a specific header value.
				As long as the MIME object does not change in any way
				this ID persisists across connections and servers.
			</t>
          <t>
            <xref target="Index-Ref">See Index.</xref>
          </t>
          <t>
            <xref target="Index-Ref">See Header ID.</xref>
          </t>
        </dd>
        <dt anchor="Index-Ref">Index</dt>
        <dd>
          <t>
				This wire protocol transmits all or part of MIME objects.
				Various parts can be referenced by an offset into the object.
				This is an index into the MIME objects.
				A client may request an index be used when opening a folder.
			</t>
          <t><em>Note</em>:	
				None of these index values are guaranteed to persist across
				re-connections to the server,
				as other clients may have altered the contents.
			</t>
        </dd>
        <dt>List ID (LID)</dt>
        <dd>
			In operations that require a list or set of data.
			This LID uniquely identifies which list or set is in context.
		</dd>
        <dt>Media Type</dt>
        <dd>
			Each MIME object has a media type that identifies the
			content of the object.
			This specification does not add, remove, or alter any MIME media type.
			This is represented in MIME objcects as the "Content-Type".
		</dd>
        <dt>MIME</dt>
        <dd>
          <t>
				This protocol transports MIME objects.
				This specification does not remove or alter any MIME objects;
			</t>
          <t>
            <xref target="Index-Ref">TODO - this link not valid.</xref>
          </t>
        </dd>
        <dt>Offset</dt>
        <dd>
			Unless otherwise specified, an offset is an unsigned 32-bit
			integer in network byte order.
		</dd>
        <dt>Packet</dt>
        <dd>
			A packet is a blob of data that has a header (its length)
			followed	by a Phoenix command with all
			of its values and parameters.

			Packets flow in both directions and asynchronously.
			Commands can be sent while still waiting for other replies.

			Each endpoint may send commands to the other endpoint without
			having to be prompted to send information.
		</dd>
        <dt>Parameter</dt>
        <dd>
			Most commands have values that are associated with them.
			These values are called parameters.
			For example, the create folder command has the name of the new
			folder to be created as a parameter.
		</dd>
        <dt>ProtoCmd</dt>
        <dd>
			A general term for all protocol commands.
			This also includes commands that do not fall into one of
			the other categories described here in this definitions section.
		</dd>
        <dt>SEQ, Command Sequence, (CMDSEQ) or (SEQ)</dt>
        <dd>
			Each command has a unique identifier, a sequence number.
			All replies to a command include the same sequence number
			as the original command.
			In this way replies can be matched up with their original command.
		</dd>
        <dt>SSL</dt>
        <dd>
			For the purpose of this specification, SSL is interchangeable
			with TLS.
			This document uses the term TLS.
			The sample implementation uses both SSL and TLS because
			the legacy UNIX, Linux, Windows, and OpenSSL code
			uses the term SSL in cases where is it TLS.
		</dd>
        <dt>TLS</dt>
        <dd>
          <t>
				A way of securely transporting data over the Internet.
			</t>
          <t>
				See <xref target="RFC8446"/>
			</t>
        </dd>
        <dt>XDR</dt>
        <dd>
          <t>
				RFC-4506 specifies a standard and compatible way to transfer
				binary information.
				This protocol uses XDR to transmit a command, its values
				and any parameters and replies.
				The MIME data, the payload, is transported as XDR opaque,
				and is unmodified.
			</t>
          <t><em>Note</em>: XDR transmits data in 32-bit chunks.
				An 8-bit value is transmitted with the lower 8-bits
				valid and the upper 24 bits set to zero.
				A 16-bit value is transmitted with the lower 16-bits
				valid and the upper 16 bits set to zero.
			</t>
          <t>
				So many of these protocol elements pack one or more
				of its parameters into one 32-bit value.
				As defined in each section.
				In many cases pseudo code is shown on how to pack the
				data and create the protocol element.
			</t>
          <t>
				See <xref target="RFC4506" section="3"/>
			</t>
        </dd>
      </dl>
    </section>
    <section xmlns:xi="http://www.w3.org/2001/XInclude" anchor="COMMANDS">
      <name>Commands Summary</name>
      <t>
		The endpoint that initiates the connection is called the client.
    The endpoint that is connected to, is called the server.
    The client is the protocol authority, and the server responds
    to client commands as configured or instructed by the client.
  </t>
      <t>
		This section provides an overview of the basic commands.
		Each command has a detailed section in this specification.
	</t>
      <t>
		When a command is sent to the remote endpoint and received,
		the remote endpoint determines if the connection is authenticated
		or authorized to perform the command.
		If not supported, or not authorized, a NotSupported command
		is send as a reply.
		The NotSupported command sent back has the same Sequence number 
		that was in the original command.
	</t>
      <t>
		Many commands are only valid after authentication.
	</t>
      <t>
		When the client connects to a server it immediately sends
		its pre authentication capabilities to the server.
		Or an Auth command.
	</t>
      <t>
		When the server gets a new connection followed by
		a pre authentication capability command, it immediately sends
		its pre authentication capabilities to the client.
	</t>
      <t>
		When the client and server have had a relationship, the
		client may send an Auth Command to initiate the authorization
		and does not send its pre authentication capability list
		to the server.
		It then waits for the Auth reply from the server.
	</t>
      <ul>
        <li>
			If the client gets an Auth reply that is positive,
			it sends its post authentication capability list to the server.
		</li>
        <li>
			If the client gets an Auth reply that is negative,
			it sends its pre authentication
			capability list to the server.
		</li>
      </ul>
      <t>
		When a servers first received packet is a Auth command,
		It processes the Auth command and sends the Auth reply.
	</t>
      <ul>
        <li>
			If the Auth reply is positive, then it also sends it
			post authentication capability list.
		</li>
        <li>
			If the Auth reply is negative, then it sends its
			pre authentication capability list to the client.
		</li>
      </ul>
      <t>
		A server may automatically send its pre authentication
		capability list to the client upon initial connection.
		Or it may wait to see if it gets a pre authentication
		capability list, or an Auth command.
	</t>
      <t>
		If the client sends an Auth command as its first packet,
		it may get the pre authentication capability from the server
		before the Auth reply. Simply process both.
	</t>
      <section anchor="PROTO_SUMMARY">
        <name>Protocol Commands Summary</name>
        <t>
		In addition to the protocols listed in this specification.
		Additional protocols and commands can be added in the future.
		They must follow the same framework listed here.
	</t>
        <t>
		This protocol connects two endpoints over a network and facilitates
		the secure and authorized transfer of MIME objects.
	</t>
        <t>
		This is a binary protocol.
		The payload can be anything, text or binary.
		This protocol was designed to reduce the number of back and forth
		requests and replies between the client and server.
		By using XDR as the format for transferring binary control
		information it is portable to any computer architecture.
		Appendix XXX has the rpcgen definition for the protocol
		defined in this specification.
	</t>
        <t>
		After the connection is successful and authenticated, ether endpoint
		may send commands to the other endpoint.
		When the server initiates an unsolicited command, it could be a
		any kind of notification or message for the client side application
		or the user. It could be reporting errors or updates to
		previous client initiated commands.
	</t>
        <t>
		All commands initiated from the client have even
		numbered command sequence numbers.
		
		All commands initiated from the server have odd
		numbered command sequence numbers.
	</t>
        <t>
		Some commands expect a command reply.
		Other commands do not expect a command reply.
		An example of a command that expects a reply is the ping command.
		An example of a command that does not expect a reply is the keep-alive
		command.
		Conceptually there are two kinds of commands:
	</t>
        <dl>
          <dt>Directive commands:</dt>
          <dd>
			A directive type command expects the other endpoint to process
			the command and possibly reply with some results.
			An example could be: Send me an index of my emails in my InBox.
			The client would expect a result.
			Another example is a bye command, once sent, no reply is expected.
		</dd>
          <dt>Request commands:</dt>
          <dd>
			A request type command may or might not have any reply.
			For example, a keep-alive command is a request to not
			timeout and has no reply.
			And a send new email notifications command would expect
			zero or more replies and it would not require them, as they
			might not happen.
		</dd>
        </dl>
        <t>
		These are not specific protocol entities, these concepts will
		be used to describe the expected behavior when one of these
		are transmitted.
	</t>
        <section anchor="PACKET_SUMMARY">
          <name>Packet Summary</name>
          <t>
			All commands are sent in a packet.
			A packet has two parts:
		</t>
          <ol>
            <li>The packet header.</li>
            <li>The packet body.</li>
          </ol>
          <t>
			The packet header has one value, the total length
			of the packet body, and payload sent as an
			unsigned 64-bit integer	in network byte order.
			The length does not include its own length.
			It is the total length that follows the length value.
		</t>
          <t>
			The packet body is divided into three parts:
		</t>
          <ol>
            <li>Command sequence (SEQ).</li>
            <li>The Command (CMD).</li>
            <li>The command specific data (Payload).</li>
          </ol>
          <section anchor="SEQ">
            <name>Command Sequence Number (SEQ)</name>
            <t>
				The Command SEQ is a 32-bit unsigned integer sent
				in network byte order.
				This SEQ is an even number when initiated from the client,
				and an odd number when initiated from the server.
			</t>
            <t>
				The first SEQ value sent from the client is zero (0) and is
				incremented by two each time.
			</t>
            <t>
				The first SEQ value sent from the server is one (1) and is
				incremented by two each time.
			</t>
            <t>
				In the event an endpoint command SEQ reaches its maximum value,
				then its numbering starts over at zero (0) for the client
				and one (1) for the server.
				An implementation must keep track of outstanding commands
				and not accidentally re-issue the same SEQ that may still
				get replies from the other endpoint.
			</t>
          </section>
          <section anchor="COMMAND">
            <name>The Command (CMD)</name>
            <t>
				The command is a predefined enumerated 32-bit unsigned
				integer sent in network byte order.
				The value (in hex) 0xFFFFFFFF is reserved for extensions
				if the 32-bit range is exhausted.
			</t>
          </section>
          <section anchor="PAYLOAD">
            <name>The Payload (Payload)</name>
            <t>
				The payload has no predefined length, other what
				what is specified for the CMD in the packet.
				It could be zero to vary large in size.
				It could be opaque data, or it could be data that
				is XDR encoded.
				The contents are specific to the CMD specified in
				the in the packet body.
			</t>
          </section>
        </section>
        <section anchor="PACKET_REPLY_SUMMARY">
          <name>Packet Reply Summary</name>
          <t>
			All replies to a command are also a command packet.
			They contain the same command SEQ and command
			as the original packet.
			The endpoint recognizes it is a reply because:
		</t>
          <ul>
            <li>
				The	command SEQ matches one that is waiting a reply.
			</li>
            <li>
				When the client gets an even numbered SEQ, it can only
				be a reply.
			</li>
            <li>
				When the server gets an odd numbered
				SEQ, it can only be a reply.
			</li>
          </ul>
          <t>
			Some commands have zero to many replies.
			Each of these multiple replies contains the same SEQ as the
			original command. An example, the client sends a request
			to be notified when new email arrives and uses command
			SEQ 20. Each time a new email arrives, a reply will
			be sent from the server with a command SEQ of 20.
			And over time, the client may get many with a SEQ of 20
			as new emails arrive on the server.
		</t>
        </section>
      </section>
      <section anchor="ADMIN_SUMMARY">
        <name>Administration Commands Summary</name>
        <t>
		Implementations are not required to implement any ADMIN command.
		A client will know the server supports one or more ADMIN
		commands when it gets its post authentication capability command
		from the server.
	</t>
        <t>
		Administrative command can be used to configure, audit, and manage
		the remote endpoint.
		Administrative command can be used to configure, audit, and manage
		user access.
	</t>
        <section anchor="ADMIN_CAP">
          <name>Administration Capability Definitions</name>
          <t>
			Implementations MUST NOT send the ADMIN capability
			in the pre authorization CAPABILITY list.
		</t>
          <t>
			Implementations that support any administration command
			MAY include ADMIN capability in the post authentication CAPABILITY list.
			An implementation may decide that only specified and
			authorized users may issue administrative commands and
			send only those authenticated users the ADMIN capability.
		</t>
          <t>
			The ADMIN capability include the list of ADMIN commands the user is
			allowed to perform.
			For example, if a user only has permission to only view user lists, then
			only the USER_LIST ADMIN capability will be provided.
		</t>
          <t>
			The capability name is also the command name to use
			when invoking that capability.
		</t>
          <t>
			When a user attempts to send a commmand they are not authorized
			to send, the remote endpoint will reply with a NotSupported command
			with its sequence number set to the sequence number from offending
			command.
		</t>
        </section>
        <section anchor="ADMIN_USER">
          <name>Administration of users.</name>
          <t>
			The following operations are defined for administration.
		</t>
          <table>
            <thead>
              <tr>
                <th>Command and Capability Name</th>
                <th>Brief Description.</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>USER_CREATE</td>
                <td>
						May create a new user.
						And also the command to create a user.
					</td>
              </tr>
              <tr>
                <td>USER_DELETE</td>
                <td>
						May delete a user.
						And the command to delete a user.
					</td>
              </tr>
              <tr>
                <td>USER_RENAME</td>
                <td>
						May rename a user.
						And the command to rename a user.
					</td>
              </tr>
              <tr>
                <td>USER_LIST</td>
                <td>
						May list users and their capabilities.
						And the command to list users.
					</td>
              </tr>
              <tr>
                <td>USER_PERMISSIONS</td>
                <td>
						May update other users permissions.
						And the command to view and set user permissions.
					</td>
              </tr>
              <tr>
                <td>SERVER_SHUTDOWN</td>
                <td>
						May shutdown the server.
						And the command to shutdown the server.
					</td>
              </tr>
              <tr>
                <td>SERVER_LOGS</td>
                <td>
						May view the server logs.
						And the command to view server logs.
					</td>
              </tr>
              <tr>
                <td>SERVER_KICK_USER</td>
                <td>
						May logout a user. And limit when they can use the server again.
						And the command to kick and limit a user.
					</td>
              </tr>
              <tr>
                <td>SERVER_MANAGE_BANS</td>
                <td>
						May manage IP and user bans.
						And the command to manage ban users an IP addresses.
					</td>
              </tr>
              <tr>
                <td>SERVER_VIEW_STATS</td>
                <td>
						May view server statistics.
						And the command to view statistics.
					</td>
              </tr>
              <tr>
                <td>SERVER_CONFIGURE</td>
                <td>
						May configure the server. If sent with a VIEW_ONLY
						parameter, then the user may only view the configuration
						information.
						And the command to view and alter the server configuration
						information.
					</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="AUTH_SUMMARY">
        <name>Authentication Commands Summary</name>
        <t>
		TODO
	</t>
      </section>
      <section anchor="CALENDAR_SUMMARY">
        <name>Calendar Commands Summary</name>
        <t>
		These command are based on iCalendar and iTIp.
	</t>
      </section>
      <section anchor="CAPABILITY_SUMMARY">
        <name>Capability Commands Summary</name>
        <t>
		This section ...
	</t>
      </section>
      <section anchor="EMAIL_SUMMARY">
        <name>EMail Commands Summary</name>
        <t>
		These commands allow for the fetching and submission
		of EMail messages
	</t>
      </section>
      <section anchor="FOLDERS">
        <name>File and Folder Commands Summary</name>
        <t>
		The file operations (FileOp) have protocol names.
		Here are their protocol names and a breif description.
	</t>
        <t>
		Implementations are not required to support any or all of these
		commands.
	</t>
        <t>
		
	</t>
        <table>
          <thead>
            <tr>
              <th>Op Name</th>
              <th>Brief Description.</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>FOLDER_CAPABILITY</td>
              <td>
					When sent as a command, request the list of
					folder commands supported.
					When sent as a reply, includes the list of
					folder commands supported.
				</td>
            </tr>
            <tr>
              <td>FOLDER_CREATE</td>
              <td>
					Create a new folder.
					Also the name of the capability for this permission.
				</td>
            </tr>
            <tr>
              <td>FOLDER_COPY</td>
              <td>
					Copy a folder.
					Also the name of the capability for this permission.
				</td>
            </tr>
            <tr>
              <td>FOLDER_DELETE</td>
              <td>
					Delete a folder.
					Also the name of the capability for this permission.
				</td>
            </tr>
            <tr>
              <td>FOLDER_RENAME</td>
              <td>
					Rename a folder.
					Also the name of the capability for this permission.
				</td>
            </tr>
            <tr>
              <td>FOLDER_METADATA</td>
              <td>
					Get, set, and update information associated with the
					folder.
					File meta data is also returned with the FOLDER_OPEN
					command.
				</td>
            </tr>
            <tr>
              <td>FOLDER_MOVE</td>
              <td>
					Move a folder.
					Also the name of the capability for this permission.
				</td>
            </tr>
            <tr>
              <td>FOLDER_OPEN</td>
              <td>
					Open a folder and get information about the folder
					and files in the folder.
				</td>
            </tr>
            <tr>
              <td>FOLDER_SHARE</td>
              <td>
					Share a folder.
					Also the name of the capability for this permission.
				</td>
            </tr>
            <tr>
              <td>FOLDER_LIST</td>
              <td>
					List folders and files.
					Also the name of the capability for this permission.
				</td>
            </tr>
            <tr>
              <td>FILE_CREATE</td>
              <td>
					Create a new file.
					Also the name of the capability for this permission.
				</td>
            </tr>
            <tr>
              <td>FILE_COPY</td>
              <td>
					Copy a file.
					Also the name of the capability for this permission.
				</td>
            </tr>
            <tr>
              <td>FILE_DELETE</td>
              <td>
					Delete a file.
					Also the name of the capability for this permission.
				</td>
            </tr>
            <tr>
              <td>FILE_RENAME</td>
              <td>
					Rename a file.
					Also the name of the capability for this permission.
				</td>
            </tr>
            <tr>
              <td>FILE_METADATA</td>
              <td>
					Get, set, and update information associated with the
					folder.
					File meta data is also returned with the FOLDER_OPEN
					command.
				</td>
            </tr>
            <tr>
              <td>FILE_MOVE</td>
              <td>
					Move a file.
					Also the name of the capability for this permission.
				</td>
            </tr>
            <tr>
              <td>FILE_SHARE</td>
              <td>
					Share a file.
					Also the name of the capability for this permission.
				</td>
            </tr>
            <tr>
              <td>FILE_GET</td>
              <td>
					Get a file.
					Also the name of the capability for this permission.
				</td>
            </tr>
            <tr>
              <td>FILE_MODIFY</td>
              <td>
					Modify the contents of an existing file.
					Also the name of the capability for this permission.
				</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="KEEPALIVE_SUMMARY">
        <name>KeepAlive Command Summary</name>
        <t>
		The KeepAlive command is sent to the server from the client.
		It requests the server not time out.
		The server may honor or ignore the request.
	</t>
        <t>
		The Phoenix protocol is designed to transfer data and a server
		may handle a small subsets of what is possible.
		Which is why the server decides what is an important command
		while determining idle timeout.
	</t>
        <t>
		When the server sends the post authentication capabilities to the
		client, it includes an IdleTimeout capability that includes the
		number of seconds it allows for idle time.
		If no significant action has been taken by the client, as determined
		by the server, in that time	the server may timeout and close the connection.
	</t>
        <t>
		The KeepAlive command tells the server that the client wishes the
		server not to time out as long as a KeepAlive or other command
		is sent to the server before IdleTimeout seconds have passed.
	</t>
        <t>
		An IdleTimeout capability can be a positive number, zero, or
		a negative number.
	</t>
        <ul>
          <li>
			A positive number is the maximum idle time in seconds before the server
			terminates the connection.
		</li>
          <li>
			When the IdleTimeout is zero (0), the server does not timeout.
		</li>
          <li>
			When the IdleTimeout is less than zero (&lt; 0), it means it ignores
			KeepAlive and it will idle out in the absolute value of the IdleTimeout
			value in seconds.
			For example, a value of (-300) means it will ignore KeepAlive
			and timeout when the server determines nothing significant has
			happened in 5 minutes (300 seconds).
		</li>
        </ul>
        <t>
		Servers that are not threaded or can not reply to simultaneous
		or overlapping commands, MUST set their IdleTimeout to zero (0)
		or a negative number.
	</t>
        <t>
		Clients MUST NOT send KeepAlive commands to a server
		that has an IdleTimeout of zero (0) or negative (&lt; 0).
	</t>
        <t>
		Clients MUST NOT send KeepAlive commands to the server until
		at least 75% of the idle time has passed since the last
		command has been sent to the server.
	</t>
        <t>
		A server may terminate a connection if the server implementation
		determines that KeepAlive commands are arriving to quickly.
	</t>
      </section>
      <section anchor="PING_SUMMARY">
        <name>Ping Command Summary</name>
        <t>
		The ping command only sent when the client implementation
		has determined it has waited too long for a command reply.
		The ping command is only initiated from the client.
		It is not valid for the server to send a ping command to a client.
	</t>
        <t>
		The ping command MUST NOT be the first command sent to the server.
		It should only be sent when the client implementation determines
		it has waited too long for a reply.
	</t>
        <t>
		If the server supports the ping command, then a PING capability
		is sent in the pre authentication capability command.
	</t>
        <t>
		Sometimes servers are unavailable and can go down.
		A server could be down for maintenance, or in a shutdown mode.
		It might limit the number of simultaneous connections.
		It might be very busy.
		The packets might not be making it to the server because of
		network issues.
	</t>
        <t>
		When a ping command is received by the server:
	</t>
        <ul>
          <li>
			When the server did not send PING capability to the client.
			Then the server replies with a NotSupported packet
			with the sequence number the same as in the ping command.
		</li>
          <li>
			When the server has not yet received an authentication
			command, the server replies with a NotSupported packet
			with the sequence number the same as in the ping command.
		</li>
          <li>
			When the server has received an authentication command,
			and has not yet replied to an authentication command.
			Then the server sends a ping reply, with the same sequence
			number that was in the ping command.
			This could happen when the client implementation had determined it
			has waited too long	for an authentication reply.
		</li>
          <li>
			When the client is authenticated,
			and when the server is available for processing commands.
			Then the server replies with a ping reply with the same sequence number.
			This could happen when the client implementation had determined it
			has waited too long	for an expected reply.
		</li>
        </ul>
        <t>
		If the server is alive and not available, the server
		will reply with a NotSupported command, with its sequence
		number set to the sequence number in the ping command.
	</t>
        <t>
		If a connected and authenticated client has been waiting for a reply
		or for some other reason needs to determine if the server is still
		available. It can send a ping command.
		If the server is still available, it sends a ping reply.
		If it is no longer available for any reason, it sends a NotSupported
		reply.
	</t>
        <t>
		Endpoints MUST NOT send a ping command if they are awaiting
		the results of a previously sent ping command.
	</t>
        <t>
		Endpoints MUST NOT send more than two ping commands per minute.
	</t>
        <t>
		Clients and servers must give priority to ping commands.
		If possible, reply as soon as it receives the command.
	</t>
        <t>
		The server MAY consider too many ping commands as a malfunctioning
		or malicious client and terminate the connection.
	</t>
        <t>
		Servers that are not threaded or can not reply to simultaneous
		or overlapping commands, MUST NOT include PING in
		their capability command.
	</t>
      </section>
      <section anchor="SMIME_SUMMARY">
        <name>S/MIME Commands Summary</name>
        <t>
		ToDo
	</t>
      </section>
    </section>
    <section anchor="META_DATA">
      <name>Meta Data</name>
      <t>
		In this specification a file and a MIME object are used
		interchangeably.
		Meta Data is data that is associated with the MIME object
		and not contained within the MIME object.
		Meta Data should never be stored in the MIME object as altering
		the MIME object would invalidate the index information and
		can invalidate digital signature and encryption information.
	</t>
      <t>
		Meta Data for the folder and MIME objects is returned in
		a FOLDER_OPEN, FILE_METADATA, or FOLDER_METADATA command.
		Meta Data can be set and updated by the client using FILE_METADATA
		or FOLDER_METADATA commands.
	</t>
      <t>
		Most are 8-bit boolean values that are set to false (0x00) or true (0x01).
		A value that does not exists is the same as a false.
	</t>
      <t>
		Meta data can be global to the object.
		That is once tagged (or not tagged) the attribute shows up for all
		users.
		Or it can be user specific meta data.
		User specific meta data does not show up for other users.
	</t>
      <t>
		Many have the same or similar name and meaning as they do
		in <xref target="RFC9051">IMAP</xref>.
	</t>
      <section>
        <name>Meta Data - Answered</name>
        <t>
			When true, the object has been replied to by the client.
			This has the same meaning as \Answered does in IMAP.
		</t>
        <t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
      </section>
      <section>
        <name>Meta Data - Attributes</name>
        <t>
			This object has been tagged with special attributes.
			It is a list of strings with matching values.
		</t>
        <t>
			User defined attributes MUST start with "X-".
			These are not portable between implementations
			and no attempt should be made to copy these
			between implementations.
		</t>
        <t>
			Non user defined attributes are described
			in other sections or specifications.
		</t>
        <t>
			This can be user specific meta data or global meta data.
			See the specific attribute documentation.
		</t>
      </section>
      <section>
        <name>Meta Data - Deleted</name>
        <t>
			When true, this object has been marked as deleted
			and has not yet been expunged.
			This has the same meaning as \Deleted does in IMAP.
		</t>
        <t>
			For shared objects, an expunge removes the
			user from shared access to the file.
			And the actual expunge is only processed
			when all shared users have expunged
			the object.
		</t>
        <t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
      </section>
      <section>
        <name>Meta Data - Draft</name>
        <t>
			When true, this object is incomplete and not ready.
		</t>
        <t>
			This has the same meaning as \Draft does in IMAP.
		</t>
        <t>
			This value can be set and unset.
			This is user specific meta data.
		</t>
      </section>
      <section>
        <name>Meta Data - Flagged</name>
        <t>
			An object has been tagged as important.
			This is the same as the IMAP \Flagged value. 
		</t>
        <t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
      </section>
      <section>
        <name>Meta Data - Forwarded</name>
        <t>
			This has the same meaning as $Forwarded does in IMAP.
		</t>
        <t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
      </section>
      <section>
        <name>Meta Data - Hide</name>
        <t>
			With NotExpungable objects, the user may wish to not view the object.
			In these cases the attribute Hide can be set.
			The attribute does not effect the view of other users.
		</t>
        <t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
      </section>
      <section>
        <name>Meta Data - Junk</name>
        <t>
			This has the same meaning as $Junk does in IMAP.
		</t>
        <t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
      </section>
      <section>
        <name>Meta Data - MDNSent</name>
        <t>
			This value can be set and unset.
			This has the same meaning as $MDNSent does in IMAP.
		</t>
        <t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
      </section>
      <section>
        <name>Meta Data - NoCopy</name>
        <t>
			When true, this MIME object can not be copied.
		</t>
        <t>
			This value can be set and unset by the owner of the file or folder.
			This value can not be unset by non owners.
			This is global meta data.
		</t>
      </section>
      <section>
        <name>Meta Data - NotJunk</name>
        <t>
			This has the same meaning as $NotJunk does in IMAP.
		</t>
        <t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
      </section>
      <section>
        <name>Meta Data - NotExpungable</name>
        <t>
			The mime object can not be marked for delete or expunged.
			It could be because it is an historical record that will never
			be expunged, or other reason.
		</t>
        <t>
			A client implementation could use the Hide attribute
			to not show the object to the user.
		</t>
        <t>
			This value can be set and unset by the owner of the file or folder.
			This value can not be unset by non owners.
			This is global meta data.
		</t>
      </section>
      <section>
        <name>Meta Data - Phishing</name>
        <t>
			This has the same meaning as $Phishing does in IMAP.
		</t>
        <t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
      </section>
      <section>
        <name>Meta Data - ReadOnly</name>
        <t>
			The MIME object associated with this attribute
			can not be altered, deleted, moved, or renamed.
			It can be copied, unless the NoCopy meta tag
			is also applied.
		</t>
        <t>
			This value can be set and unset by the owner of the file or folder.
			This value can not be unset by non owners.
			This is global meta data.
		</t>
        <t>
			Setting of this to false may fail if the file or folder is
			stored on read-only media.
			When the file or folder is stored on read-only media,
			this MUST BE set to true.
		</t>
      </section>
      <section>
        <name>Meta Data - Shared</name>
        <t>
			The MIME object associated with this attribute
			is shared and is also often tagged with the ReadOnly
			meta data tag.
		</t>
        <t>
			This value can not be set and unset by the owner.
		</t>
        <t>
			If copying of the file or folder is allowed, then
			the shared attribute is removed when copied.
		</t>
        <t>
			This file or folder will only be expunged when all
			of the users with shared access have deleted and
			expunged it.
		</t>
      </section>
      <section>
        <name>Meta Data - Seen</name>
        <t>
			This has the same meaning as \Seen does in IMAP.
		</t>
        <t>
			This value can be set and unset.
			This is user specific meta data because it
			also applies to shared folders and files.
		</t>
      </section>
      <section>
        <name>Meta Data - MDNData Attribute</name>
        <t>
			This Meta Data Attribute is only visible to the
			owner of the object for which MDN has been set.
		</t>
        <t>
			This is a list of recipients email address that
			that are on the distribution list effected by the MDN.
		</t>
        <t>
			The format of an MDNData record is
			a header, that has:
		</t>
        <ul>
          <li>
				COUNT: A 32-bit unsigned integer in network byte order
				indicating how many were on the distribution list
				for this MDN.
			</li>
          <li>
				SENT: The UTC timestamp as a 64-bit unsigned integer
				in network byte order of when the MDN reply was sent.
			</li>
        </ul>
        <t>
			Followed by COUNT detail records:
		</t>
        <ul>
          <li>
				UTC: The UTC timestamp as a 64-bit unsigned integer
				in network byte order of when the MDN reply was received.
				Set to zero if not received.
			</li>
          <li>
				Email-Address: A PhoenixString with the associated
				email address of the user that has or has not returned
				the MDN.
			</li>
        </ul>
        <figure anchor="MDNData" align="center">
          <name>MDNData Attribute</name>
          <artset>
            <artwork type="ascii-art" src="MDN-00.txt"/>
            <artwork type="svg" src="MDN-00.svg"/>
          </artset>
        </figure>
      </section>
      <section>
        <name>Meta Data with Shared Objects</name>
        <t>
			When a server implementation allows shared objects,
			the meta data returned to the client may be different
			depending on the authenticated user.
			Some users may have read only copies, other may be
			able to delete the object.
		</t>
        <t>
			When a shared object is deleted, it is marked as deleted for
			only the user that issued the delete.
		</t>
        <t>
			When a shared object is expunged, its access is removed
			for the user that issued the expunge.
			After all users have expunged the object, then it is
			removed by the server.
		</t>
        <t>
			There are two kinds of expunge for shared objects.
			Force and delayed.
		</t>
        <ul>
          <li>
            <t>
					Forced:
				</t>
            <t>
					A forced expunge can be the result of security policies
					at the server, site, or administrators discretion.
					This also is how timed messages are deleted.
				</t>
            <t>
					In order for a shared object that is expunged to not
					force an immediate re-index for all clients, the server sends
					an expunge to all clients, where the client MUST immediately make
					the object not show	to the user and MUST invalidate
					any cached or memory copy of the data.
					Then when convenient, the client can do a re-index
					of the folder.
					When a user is viewing the object when an expunge
					arrives, the client must inform the user that the data
					is no longer available and replace the user view of
					the data with an empty object or move the view to
					another object.
				</t>
            <t>
					Server implementations must prioritize forced expunge notices
					to the clients and immediately reject all attempts to read,
					view, copy, or access meta data.
				</t>
          </li>
          <li>
            <t>
					Delayed:
				</t>
            <t>
					The user is informed the MIME object is no longer available.
					The client implementation may continue to show the object.
					The client may copy the MIME object, unless tagged as
					NoCopy.
				</t>
            <t>
					The next time the client does an expunge the object will be
					expunged from the client.
				</t>
            <t>
					When a client application closes, all delayed expunges
					MUST occur at exit.
				</t>
            <t>
					When a client applications starts the client MUST check for
					delayed expunges that have not been processed and expunge them
					and not	allow the user to see them.
				</t>
            <t>
					Server implementations must reject attempts to fetch or view
					a folder or file or any of its meta data when an expunge has started,
					and not yet completed.
				</t>
          </li>
        </ul>
      </section>
    </section>
    <section anchor="WIREPROTOCOLDETAIL">
      <name>Over the Wire Protocol Detail</name>
      <t>
		This section specifies the details of what is
		transmitted over the network.
	</t>
      <t>
		All protocol data transmitted between the endpoints is sent in
		network byte order.
	</t>
      <t>
		All payload data transmitted between the endpoints is sent
		in original format.
		The payload consent is seen as an opaque blob of data within
		a command packet.
	</t>
      <t>
		When a command packet is received by ether endpoint it:
		(1) Checks the command sequence number to determine if it is a reply
		or not.
		(2) If it is a reply, it looks at the command and dispatches
		it to the implementations commands reply code.
		(3) If is not a reply, it looks at the command and dispatches
		it to the implementations command code.
	</t>
      <t>
		A command and all of its replies, use the same format as
		described here.
	</t>
      <t>
		A packet has a 32-bit unsigned integer in network byte
		order that is set to the octet count of all of the
		data that follows this length value.
		The shortest packet is 16 octets in size, with
		a length value set to 8. With 8 octets for the length, and 8 octets
		for the packet.
	</t>
      <t>
		Followed by a 32-bit unsigned integer in network byte
		order that is the command sequence number.
	</t>
      <t>
		Followed by a 32-bit unsigned integer in network byte
		order that is the command.
	</t>
      <t>
		Followed by zero or more octets of payload data.
	</t>
      <t>
		There is no space, padding, or line endings between the parts
		of the packet.
		The payload is sent without any modification and is not
		encoded or transformed in any way.
		A packet is shown here vertically only
		to aid in readability.
	</t>
      <artset>
        <artwork type="ascii-art" src="Packet-00.txt"/>
        <artwork type="svg" src="Packet-00.svg"/>
      </artset>
      <t>
		ABNF:
	</t>
      <sourcecode>

CommandHeader : Length:32 Sequence:32 CMD:32

Command : CommandHeader Payload

	</sourcecode>
      <t>
		The payload size and format varies for each command.
		The details of the payload content, and the format
		of that content, is described in each specific CMD section.
	</t>
      <t>
		An implementation can send, receive, and dispatch packets within
		its implementation by looking at the length, SEQ, and CMD, then
		passing the payload to code that can handle that payload.
	</t>
      <t>
		- Read in a 64-bit value.
		- Convert the value from network byte order, to host byte order. This is the
		total length of the data that follows.
		- Read in length octets into the packet payload.
		- Get the 32-bit value in the payload, it is the SEQ in network byte order.
		- Convert the SEQ from network byte order, to host byte order.
		- Get another 32-bit value in the payload, it is the CMD in network byte order.
		- Convert the CMD from network byte order, to host byte order.
		- Dispatch the CMD with SEQ and all of the data that follows
		to implementation 
	</t>
      <t>
		The following is pseudo code that explains how processing incoming XDR
		data can be handled:
	</t>
      <sourcecode><![CDATA[
  // Where:
  //  uint32_t, is a 32-bit unsigned integer.
  //  uint8_t *, is a pointer to 8-bit data.
  //  XDR, is an XDR object.
  //
  //  CmdPacket, is an object that represents all commands
  //  and replies.
  //
  //  NOTE: See the sample implementation.
  //
  uint32_t   NetLength;
  uint32_t   PacketLength;
  uint8_t *  Data;
  uint8_t *  DataPointer;
  XDR        Xdr;
  CmdPacket  Packet;
  
  // Read the length and convert to host byte order.
  //
  read(FromClientSocket, &NetLength, sizeof(uint32_t));
  PacketLength = ntohll(NetLength);

  // Allocate PacketLength data, and read it.
  //
  Data = new uint8_t[PacketLength]
  DataPointer = Data;

  // Initialize the XDR deserializer.
  //
  xdrmem_create(&Xdr, Data, PacketLength, XDR_DECODE);

  // Decode the received data into a Packet.
  //
  if (xdr_CmdPacket(&Xdr, &Packet)) {

    // If the lowest bit is set, it is an odd number.
    //
    if (Packet.Sequence & 0x01) {
      SequenceIsEvenNumber = false;
    } else {
      SequenceIsEvenNumber = true;
    }

    // The client sends even numbered sequences, and the server
    // sends the same even numbers sequence in the reply to
    // the command.
    //
    // If a client gets an odd numbered sequence, it is a command 
    // from the other endpoint.
    //
    // The server sends odd numbered sequences, and the client
    // sends the same odd numbers sequence in the reply to
    // the command.
    //
    // If a server gets an even numbered sequence, it is a
    // command from the other endpoint.
    //
    if (WeAreTheClient) {
      if (SequenceIsEvenNumber) {
        DispatchReply(Packet);
      } else {
        DispatchCommandFromOtherEndpoint(Packet);
      }
    } else {
      if (SequenceIsEvenNumber) {
        DispatchCommandFromOtherEndpoint(Packet);
      } else {
        DispatchReply(Packet);
      }
    }
  }
]]></sourcecode>
    </section>
    <section anchor="INDEX">
      <name>Index</name>
      <section anchor="InterestedHeaders">
        <name>Interested Headers</name>
        <t>
			Some implementation may wish to specify which MIME headers
			it wants to get in the index supplied by the server.
			This is done as part of the folder selection command which
			can supply a list of desired headers.
			Or it can specify a list ID that has already been transmitted.
			When none are supplied, no header index values will be returned.
		</t>
        <t>
			This list can be the same for all folders, or unique to specific folders.
			The client generates a list of interested headers and
			sends an Interested Headers list or list ID to the server when selecting
			a folder.
		</t>
        <section anchor="InterestedHeaders-LID">
          <name>List ID (LID)</name>
          <t>
				A List ID (LID) is a unsigned integer ranging from 0 to 254.
				It is used in requests and replies to refer to the interested headers
				list.
				A client can have up to 254 (LID 0 to 254) lists per connection.
				The value 255 is reserved for expansion.
			</t>
          <t>
				Restrictions:
			</t>
          <ul>
            <li>
					The list IDs are unique to the connection and do not persist
					across connections.
				</li>
            <li>
					No two lists can have the same ID within a connection.
				</li>
          </ul>
          <t>
				ABNF:
			</t>
          <artwork type="abnf" name="" align="left" alt=""><![CDATA[
LID    = uint8_t;				
]]></artwork>
        </section>
        <section anchor="InterestedHeaders-IndexOP">
          <name>Index Operation (IndexOP)</name>
          <t>
				An Index Operation (IndexOP) has only one of two values:
			</t>
          <ul>
            <li>
              <t>
						IndexOPDefine = 0
					</t>
              <t>
						Used to define a list of body MIME object, and Body Part,
						interesting headers the client cares about.
						When the LID is already defined, then this redefines it.
						When the LID is not already defined, it creates a new list.
						The results will come back as an Folder-Index in a
						successful FOLDER_OPEN reply.
					</t>
            </li>
            <li>
              <t>
						IndexOPUse = 1
					</t>
              <t>
						This indicates that LID is an existing list number to use.
						LID has previously been defined in this session.
						The results will come back as an Folder-Index in a
						successful FOLDER_OPEN reply.
					</t>
            </li>
          </ul>
        </section>
        <section anchor="InterestedHeaders-HID">
          <name>Header ID (HID)</name>
          <t>
				A Header ID (HID) is an unsigned integer ranging
				from 0 to 254.
				The client assigned the HID value to a header name, then
				the client and server references it by HID in packets and replies.
				A client can have up to 254 interested headers per connection.
				The value 255 is reserved for expansion.
			</t>
          <t>
				ABNF:
			</t>
          <artwork type="abnf" name="" align="left" alt=""><![CDATA[
HID    = uint8_t;				
]]></artwork>
        </section>
        <section anchor="InterestedHeaders-Lists">
          <name>Lists</name>
          <t>
				The client sends a list to the server as part of
				a FOLDER_OPEN.
				One of the parameters to a FOLDER_OPEN is an interested
				header list.
				A successfule reply to a FOLDER_OPEN will include
				indexes into the MIME object for the desired header values.
			</t>
          <t>
				The list can be defined in the same packet.
				Or it can use an already defined list.
				Or it can not request any header indexes by defining or using
				a list that has zero entries.
			</t>
          <t><xref target="Interisting-S0-01"/>, shows the interisted
				header list prefix.
				This interisted header list prefix is followed by zero or more
				SingleEntry objects.
			</t>
          <table>
            <thead>
              <tr>
                <td>
							Name
						</td>
                <td>
							XDR Type
						</td>
                <td>
							Description
						</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
							IndexOP
						</td>
                <td>
							uint8_t
						</td>
                <td>
							IndexOPis used to specify headers the client
							wishes the server to index in MIME objects.
							It must be a zero (0) to set the list definition.
						</td>
              </tr>
              <tr>
                <td>
							LID
						</td>
                <td>
							uint8_t
						</td>
                <td>
							LID is the list ID of the list that client is defining.
							With 255 reserved for	expansion.
						</td>
              </tr>
              <tr>
                <td>
							HDRCNT
						</td>
                <td>
							uint8_t
						</td>
                <td>
							HdrCnt is set by the client to the number of headers in the list.
							With 255 reserved for	expansion.
						</td>
              </tr>
            </tbody>
          </table>
          <figure anchor="Interisting-S0-01" align="center">
            <name>Interest Header List Prefix</name>
            <artset>
              <artwork type="ascii-art" src="IndexList-01.txt"/>
              <artwork type="svg" src="IndexList-01.svg"/>
            </artset>
          </figure>
          <t>
				ABNF:
			</t>
          <sourcecode>
DefineListOp  = 0x01:8
				
Interest-Header = DefineListOp LID HdrCnt
			</sourcecode>
          <section anchor="InterestedHeader-Entry">
            <name>Interested Headers - Single Entry</name>
            <t>
					Following interest header list prefix data is zero or more
					of these single header entries.
					One sent for each HdrCnt in the prefix.
					This list informs the server the HID value that
					will be used for each interested header in the index
					that the server replies with.
					As shown in  <xref target="Interisting-S0-02"/>, where:
				</t>
            <table>
              <thead>
                <tr>
                  <td>
								Name
							</td>
                  <td>
								XDR Type
							</td>
                  <td>
								Description
							</td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
								HID
							</td>
                  <td>
								uint8_t
							</td>
                  <td>
								HID is the client assigned unique header ID
								for the named header.
								This is an 8-bit unsigned integer.
							</td>
                </tr>
                <tr>
                  <td>
								HEADER NAME
							</td>
                  <td>
								PhoenixString
							</td>
                  <td>
                    <t>
									THE HEADER NAME is the characters that make
									up the MIME header name	that is interesting
									without including any terminating zero (0).
								</t>
                  </td>
                </tr>
              </tbody>
            </table>
            <figure anchor="Interisting-S0-02" align="center">
              <name>Setting the Interest List - Contents</name>
              <artset>
                <artwork type="ascii-art" src="IndexList-02.txt"/>
                <artwork type="svg" src="IndexList-02.svg"/>
              </artset>
            </figure>
            <t>
					ABNF:
				</t>
            <sourcecode>
SingleHeader = HID PhoenixString
				</sourcecode>
          </section>
          <section anchor="InterestedHeader-GetIndex">
            <name>Interested Headers - Use Existing List</name>
            <t>
					When the IndexOP flag is set to one (1) then it is followed by
					an existing list ID	number.
				</t>
            <t>
					LID, the list ID of an already transmitted list to be used.
				</t>
            <t>
					This is sent as a 32-bit unsigned integer in network byte order.
				</t>
            <figure anchor="Interisting-S0-03" align="center">
              <name>Using Existing Header Index by List ID (LID)</name>
              <artset>
                <artwork type="ascii-art" src="IndexList-03.txt"/>
                <artwork type="svg" src="IndexList-03.svg"/>
              </artset>
            </figure>
            <t>
					ABNF:
				</t>
            <sourcecode>
UseExistingOp      = 0x01:8
					
UseExistingList:32 = UseExistingOp LID 0x00:8

				</sourcecode>
          </section>
          <section>
            <name>Example: Setting the Interested Header List</name>
            <t>
					This is an example of the client sending an
					interesting header list to the server.
					The client is asking for the index values
					for the following MIME headers (1) From, and (2) Subject.
					And for the following Body part headers (1) Content-Type.
				</t>
            <figure anchor="Interisting-S0-04" align="center">
              <name>Example Setting a List</name>
              <artset>
                <artwork type="ascii-art" src="IndexList-04.txt"/>
                <artwork type="svg" src="IndexList-04.svg"/>
              </artset>
            </figure>
            <t>
					Where:
				</t>
            <ul>
              <li>
                <t>
							(a): A 32-bit unsigned integer in network byte order
							as described in <xref target="Interisting-S0-01"/>.
						</t>
                <t>The first 8-bits are zero.</t>
                <t>The IndexOP of zero, which means defining a list.</t>
                <t>
							And in this example two (0x02) MIME object headers
							are requested	to be indexed, "From", and "Subject".
						</t>
              </li>
              <li>
                <t>
							(b): A 32-bit unsigned integer in network byte order
							as described in <xref target="Interisting-S0-02"/>.
						</t>
                <t>
							The header ID that the client and server will use to
							to identify the "From" header name will be zero (0)
							in this example.
						</t>
                <t>
							The length of the string "From" is four (4)
							and its length is the lower 24 bits of this entry.
						</t>
              </li>
              <li>
                <t>
							(c) A series of 8-bit unsigned values packed into one or more
							32-bit unsigned integers in network byte order.
						</t>
                <t>
							Each 8-bit value is the value of the letters in "From".
							As "From" is a multiple of 32-bits, no padding is done.
						</t>
              </li>
              <li>
                <t>
							(d): A 32-bit unsigned integer in network byte order
							as described in <xref target="Interisting-S0-02"/>.
						</t>
                <t>
							The header ID that the client and server will use to
							to identify the "Subject" header name will be one (1)
							in this example.
						</t>
                <t>
							The length of the string "Subject" is seven (7)
							and its length is the lower 24 bits of this entry.
						</t>
              </li>
              <li>
                <t>
							(e) A series of 8-bit unsigned values packed into one or more
							32-bit unsigned integers in network byte order.
						</t>
                <t>
							Each 8-bit value is the value of the letters in "Subject".
						</t>
                <t>
							As The length of "Subject" is not a multiple of 32-bits,
							the remaining bits are ignored.
							Shown as zero in this example.
						</t>
              </li>
              <li>
						(f) The two MIME objects headers are done, start of Body Part
						headers, and there is one (1) of them.
						IndexOP and LID are not used here.
					</li>
              <li>
						(g) The second header will be identified as three (3).
						The first body part header is 12 octets long (0xc): 'Content-Type'.
					</li>
              <li>
						(h) The value of the characters for 'Content-Type'.
					</li>
              <li>
						(i) The rest of the value of the characters for 'Content-Type'.
					</li>
            </ul>
          </section>
        </section>
      </section>
      <section anchor="PhoenixString">
        <name>PhoenixString</name>
        <t>
			This protocol references the strings by octet offset into the entire
			message.
			All strings can be referenced by using a total of 8 octets.
			A Phoenix string consists of two parts:
		</t>
        <ul>
          <li>
				Offset: A 32-bit unsigned integer in network byte order.
				The octet count to the start of the string with zero being the
				first octet in the message.
				
			</li>
          <li>
				Length: The length in octets of the string.
				A 32-bit unsigned integer in network byte order.
			</li>
        </ul>
        <t>
			A Phoenix string over the wire is 8 octets in size.
		</t>
        <figure anchor="PhoenixStringFigure" align="center">
          <name>Phoenix String Format</name>
          <artset>
            <artwork type="ascii-art" src="PhoenixString-00.txt"/>
            <artwork type="svg" src="PhoenixString-00.svg"/>
          </artset>
        </figure>
        <t>
			ABNF:
		</t>
        <sourcecode>
PhoenixString = Offset:32 Length:32 String
		</sourcecode>
      </section>
      <section>
        <name>MIME Folder Index</name>
        <t>
			In this specification, a MIME folder is also called a folder.
			And can be files containing MIME objects on a disk that have
			a defined order, or sequence of MIME objects in one file.
		</t>
        <t>
			A folder index is a summary of the contents of a MIME folder.
			It may include the basic header information.
			It does include location information provided as the octet count to the
			start of the beginning of the related target data.
		</t>
        <ul>
          <li>
				An index is an unsigned 32-bit integer in network byte order.
			</li>
          <li>
				A length is an unsigned 32-bit integer in network byte order.
			</li>
        </ul>
        <t>
			For example, if a MIME folder contains 100 MIME messages, then
			the folder index will have 100 message indexes.
			Each message will have header indexes for the interested headers.
			Each message index will	contain 1 or more body part indexes.
			Each body part will have header indexes with zero (0) or more entries.
		</t>
        <section>
          <name>Folder Index Header</name>
          <t>
				A folder index consists of:
			</t>
          <ul>
            <li>
					The entire length of the index as a 32-bit unsigned
					integer in network byte order of what follows this value.
					Allowing the recipient of this index to do one read
					and process later.
				</li>
            <li>
					The number of message indexes in this folder index.
					As an unsigned 32-bit integer in network byte order.
				</li>
          </ul>
          <t>
				The index header is 8 octets, that is followed by
				the each message index:
			</t>
          <figure anchor="FolderIndexHeaderFigure" align="center">
            <name>Folder Index</name>
            <artset>
              <artwork type="ascii-art" src="IndexList-05.txt"/>
              <artwork type="svg" src="IndexList-05.svg"/>
            </artset>
          </figure>
          <t>
				ABNF:
			</t>
          <sourcecode>
FolderIndexHeader = FolderIndexSize:32 MessageCount:32 ArrayOfMsgIndex
			</sourcecode>
          <t>
				The header is followed by an array of message indexes.
				They are an ordered list of references to each message.
				In the order they appear in the folder:
			</t>
        </section>
        <section>
          <name>Message Index</name>
          <ul>
            <li>
					A 32-bit unsigned integer in network byte order that is
					the offset into the folder of the message.
					A Message offset is unique in a MIME folder, it is used both as
					an offset into the MIME folder,
					and as a unique ID within a MIME folder for a message.
				</li>
            <li>
					An a length of the message as a 32-bit unsigned integer
					in network byte order.
				</li>
          </ul>
          <figure anchor="MessageIndexFigure" align="center">
            <name>Message Index</name>
            <artset>
              <artwork type="ascii-art" src="IndexList-07.txt"/>
              <artwork type="svg" src="IndexList-07.svg"/>
            </artset>
          </figure>
          <t>
				ABNF:
			</t>
          <sourcecode>
MessageIndex = OfffsetIntoFolder:32 MessageLength:32 ArrayOfHeaderIndex
				
ArrayOfMsgIndex = MessageIndex*
			</sourcecode>
          <t>
				For each message index is an ordered list of interested headers.
				The interested header list is assignable by the client and body
				part indexes.
				It consists of offsets to the interested headers and associated value.
				Each interested header can be indexed with nine (9) octets.
				and consists of:
			</t>
        </section>
        <section>
          <name>Header Index</name>
          <ul>
            <li>
					ID-CNT:
					A count of matched headers.
					Only matched headers will be included.
					If they are not included, no such header existed
					in the object.
				</li>
            <li>
              <t>
						The number of body parts in this object.
						An unsigned 8-bit number.
						With MIME, body parts may contain body parts.
					</t>
              <t>
						Any MIME preamble and epilogue are not counted as body parts
						A preamble, if it exists, can be easily be calculated as it starts
						as the first	octet after the header area.
						And the epilogue, if it exists, can be calculated as starting as
						the first
						octet after the last MIME boundary.
					</t>
            </li>
            <li>
					Followed by an array of ID-CNT 8-bit client assigned HID values
					that matched.
					Padded to round up to 32-bits.
					The unused bits are ignored and shown as zero in this specification.
				</li>
          </ul>
          <t>
				A single header index consists of the list description,
				followed by the index values.
				There are two header indexes in each Message index.
			</t>
          <ol>
            <li>The first is for the MIME object itself.</li>
            <li>
					The second is for the objects Body Parts.
					This part will not exists exist when it is an RFC-822
					style message or has no body parts.
					Followed by the header index.
					This second part also include an offset to the start
					of the body part itself in the MIME object.
				</li>
          </ol>
          <t>
				A list description is one 8-bit result count,
				followed by the list of matching header ID's (HID).
			</t>
          <t>
				If the list description is not a multiple of 32-bits
				then padding is added and the extra are ignored and shown as
				zero in this specification.
			</t>
          <sourcecode>
-Meta-Data-: Seen,Answered,$NotJunk
			</sourcecode>
          <figure anchor="HeaderIndex2" align="center">
            <name>Header Index</name>
            <artset>
              <artwork type="ascii-art" src="IndexList-10.txt"/>
              <artwork type="svg" src="IndexList-10.svg"/>
            </artset>
          </figure>
          <t>
				ABNF:
			</t>
          <sourcecode>
HeaderIndex          = HeaderIndexHeader:32 ArrayOfHID*
                       PhoenixString* BodyPartIndex*

                       ; One HID (HeaderID) for each match header
                       ; in the LID provided. Padded out to multiples
                       ; of 32-bits.
HeaderIndexHeader:32 = ID-CNT:8 Body-Count:8
                       / (HID HID)
                       / (HID 0x00:8)
                       / (0x00:8 0x00:8)

ArrayOfHid           = HIDEntry*

BodyPartIndex        = BodyPartOffset:32 HeaderIndexHeader:32 PhoenixString*
                       BodyPartIndex*

ID-CNT:8               ; The number of headers found in the
                       ; MIME object and requested in the interested
                       ; header list.

Body-CNT:8             ; The number of body parts in the object

                       ; Padded out to multiples of 32-bits.
HidEntry             = (HID:8 HID:8 HID:8 HID:8)
                       / (HID:8 HID:8 HID:8 0x00:8)
                       / (HID:8 HID:8 0x00:8 0x00:8)
                       / (HID:8 0x00:8 0x00:8 0x00:8)
			</sourcecode>
          <t>
				Where:
			</t>
          <t>
				HeaderIndex: The header index starts with a 32-bit unsigned
				integer in network byte order, the HeaderIndex:32.
			</t>
          <t>
				HeaderIndex:32: Contains 0, 1, or 2 HID values.
				They are in the order found in the object.
			</t>
          <t>
				ArrayIfHID: Keeps repeating until all of the
				headers in the list have been found in the message.
				The last one pads with zeros when needed.
			</t>
          <t>
				BodyPartIndex: When the object has body parts,
				there will be a BodyPartIndex for each body part,
				in the order they are in the object.
				The first 32-bits are the offset to the start
				of the body part. This does not include any boundary.
			</t>
          <t>
				Body parts themselves may contain body parts,
				they are recursively included as needed.
			</t>
        </section>
        <section>
          <name>Header Index Example 1</name>
          <t>
				For example, if the client requested MIME object indexes for the
				"From",	"Subject", "To", "Message-ID",
				"Content-Type", "MIME-Version", and "Date"
				header values.
			</t>
          <t>
				Assume this is an RFC-822 message with no body parts.
				So the body part header index has a count of zero (0).
				And the HID values assigned by the client when opening
				the folder are:
			</t>
          <ul>
            <li>From: 0</li>
            <li>Subject: 1</li>
            <li>To: 2</li>
            <li>Message-ID: 3</li>
            <li>Content-Type: 4</li>
            <li>Data: 5</li>
            <li>MIME-Version: 6</li>
          </ul>
          <t>
				In the Message each line is terminated with a carriage
				return and line feed:
			</t>
          <sourcecode><![CDATA[
From: Doug@example.com
To: Notices@example.com, Supervisors@example.com, Dave@example.com
Date: Thu, 06 Feb 2025 20:29:35 +0000
MessageID: <7324e0b9-f6dc-3c9b-a02f-0b2b824e863c@example.com>
Subject: A new draft of Phoenix has been published.
Content-Type: text/plain

A new draft has been published.

]]></sourcecode>
          <figure anchor="HeaderIndexFigure1" align="center">
            <name>Header Index</name>
            <artset>
              <artwork type="ascii-art" src="IndexList-08.txt"/>
              <artwork type="svg" src="IndexList-08.svg"/>
            </artset>
          </figure>
        </section>
        <section>
          <name>Header Index Example 2</name>
          <t>
				For example, if the client requested MIME object indexes for the
				"From",	"Subject", "To", "MIME-Version", and "Content-Type".
				header values.
			</t>
          <t>
				And when the folder was opened, the client asked for
				the "Content-Type" header.
			</t>
          <t>
				Assume this is a MIME message with two body parts.
				So the body part header index has a count of two (2).
				And the HID values assigned by the client when opening
				the folder are:
			</t>
          <ul>
            <li>From: 8</li>
            <li>Subject: 12</li>
            <li>To: 4</li>
            <li>Content-Type: 3</li>
            <li>MIME-Version: 9</li>
          </ul>
          <t>
				In the Message each line is terminated with a carriage
				return and line feed:
			</t>
          <sourcecode><![CDATA[
From: User@example.com
To: User2@example.com
Subject: This is the subject of a sample message
MIME-Version: 1.0
Content-Type: multipart/alternative; boundary="XXXXboundary text"

--XXXXboundary text
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: quoted-printable

This is the body text of a sample message

--XXXXboundary text
Content-Type: text/html; charset="utf-8"
Content-Transfer-Encoding: quoted-printable

This is the body text of a sample message.
--XXXXboundary text--

]]></sourcecode>
          <figure anchor="HeaderIndexFigure2" align="center">
            <name>Header And Body Part Index</name>
            <artset>
              <artwork type="ascii-art" src="IndexList-09.txt"/>
              <artwork type="svg" src="IndexList-09.svg"/>
            </artset>
          </figure>
        </section>
      </section>
    </section>
    <section anchor="IANA">
      <!-- All drafts are required to have an IANA considerations section. See RFC 8126 for a guide.-->
      <name>IANA Considerations</name>
      <t>This memo includes no request to IANA. [CHECK]</t>
    </section>
    <section anchor="Security">
      <!-- All drafts are required to have a security considerations section. See RFC 3552 for a guide. -->
      <name>Security Considerations</name>
      <t>This document should not affect the security of the Internet. [CHECK]</t>
    </section>
    <!-- NOTE: The Acknowledgements and Contributors sections are at the end of this template -->
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="RFC0822" target="https://www.rfc-editor.org/info/rfc822" xml:base="../References/reference.RFC.0822.xml">
          <front>
            <title>STANDARD FOR THE FORMAT OF ARPA INTERNET TEXT MESSAGES</title>
            <author fullname="D. Crocker" initials="D." surname="Crocker"/>
            <date month="August" year="1982"/>
            <abstract>
              <t>This document revises the specifications in RFC 733, in order to serve the needs of the larger and more complex ARPA Internet. Some of RFC 733's features failed to gain adequate acceptance. In order to simplify the standard and the software that follows it, these features have been removed. A different addressing scheme is used, to handle the case of internetwork mail; and the concept of re-transmission has been introduced. Obsoletes RFC 733, NIC 41952.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="11"/>
          <seriesInfo name="RFC" value="822"/>
          <seriesInfo name="DOI" value="10.17487/RFC0822"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" xml:base="../References/reference.RFC.2119.xml">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner"/>
            <date month="March" year="1997"/>
            <abstract>
              <t>In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC4506" target="https://www.rfc-editor.org/info/rfc4506" xml:base="../References/reference.RFC.4506.xml">
          <front>
            <title>XDR: External Data Representation Standard</title>
            <author fullname="M. Eisler" initials="M." role="editor" surname="Eisler"/>
            <date month="May" year="2006"/>
            <abstract>
              <t>This document describes the External Data Representation Standard (XDR) protocol as it is currently deployed and accepted. This document obsoletes RFC 1832. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="67"/>
          <seriesInfo name="RFC" value="4506"/>
          <seriesInfo name="DOI" value="10.17487/RFC4506"/>
        </reference>
        <reference anchor="RFC5234" target="https://www.rfc-editor.org/info/rfc5234" xml:base="../References/reference.RFC.5234.xml">
          <front>
            <title>Augmented BNF for Syntax Specifications: ABNF</title>
            <author fullname="D. Crocker" initials="D." role="editor" surname="Crocker"/>
            <author fullname="P. Overell" initials="P." surname="Overell"/>
            <date month="January" year="2008"/>
            <abstract>
              <t>Internet technical specifications often need to define a formal syntax. Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications. The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power. The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges. This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="68"/>
          <seriesInfo name="RFC" value="5234"/>
          <seriesInfo name="DOI" value="10.17487/RFC5234"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" xml:base="../References/reference.RFC.8174.xml">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t>RFC 2119 specifies common key words that may be used in protocol specifications. This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8446" target="https://www.rfc-editor.org/info/rfc8446" xml:base="../References/reference.RFC.8446.xml">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
            <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
            <date month="August" year="2018"/>
            <abstract>
              <t>This document specifies version 1.3 of the Transport Layer Security (TLS) protocol. TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
              <t>This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961. This document also specifies new requirements for TLS 1.2 implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8446"/>
          <seriesInfo name="DOI" value="10.17487/RFC8446"/>
        </reference>
        <reference anchor="RFC9051" target="https://www.rfc-editor.org/info/rfc9051" xml:base="../References/reference.RFC.9051.xml">
          <front>
            <title>Internet Message Access Protocol (IMAP) - Version 4rev2</title>
            <author fullname="A. Melnikov" initials="A." role="editor" surname="Melnikov"/>
            <author fullname="B. Leiba" initials="B." role="editor" surname="Leiba"/>
            <date month="August" year="2021"/>
            <abstract>
              <t>The Internet Message Access Protocol Version 4rev2 (IMAP4rev2) allows a client to access and manipulate electronic mail messages on a server. IMAP4rev2 permits manipulation of mailboxes (remote message folders) in a way that is functionally equivalent to local folders. IMAP4rev2 also provides the capability for an offline client to resynchronize with the server.</t>
              <t>IMAP4rev2 includes operations for creating, deleting, and renaming mailboxes; checking for new messages; removing messages permanently; setting and clearing flags; parsing per RFCs 5322, 2045, and 2231; searching; and selective fetching of message attributes, texts, and portions thereof. Messages in IMAP4rev2 are accessed by the use of numbers. These numbers are either message sequence numbers or unique identifiers.</t>
              <t>IMAP4rev2 does not specify a means of posting mail; this function is handled by a mail submission protocol such as the one specified in RFC 6409.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9051"/>
          <seriesInfo name="DOI" value="10.17487/RFC9051"/>
        </reference>
      </references>
      <references>
        <name>Informative References</name>
        <reference anchor="exampleRefMin">
          <!-- [REPLACE/DELETE] Example minimum reference -->
          <front>
            <title>Title [REPLACE]</title>
            <author initials="Initials [REPLACE]" surname="Surname [REPLACE]">
              <organization/>
            </author>
            <date year="2006"/>
            <!-- [CHECK] -->
          </front>
        </reference>
        <reference anchor="exampleRefOrg" target="http://www.example.com/">
          <!-- [REPLACE/DELETE] Example reference written by an organization not a person -->
          <front>
            <title>Title [REPLACE]</title>
            <author>
              <organization>Organization [REPLACE]</organization>
            </author>
            <date year="1984"/>
            <!-- [CHECK] -->
          </front>
        </reference>
      </references>
    </references>
    <section anchor="ADMINBINARYVALUES_APPENDIX">
      <name>Administrative Enumerated Binary Values</name>
      <t>
		Phoenix is a binary protocol.
		Each value is sent as an unsigned 32-bit integer in xdr format.
	</t>
      <t>
		The values for the commands are arbitrary and were assigned
		as created. There is no plan or origination to the numbers.
		There is no priority or superiority to any value.
		The table is sorted by name, not value.
	</t>
      <t>
		The values are not unique. They are only unique within the context
		in which they are used.
	</t>
      <t>
		Some of these values are reused for other commands.
		For example USER_CREATE is both an (a) AUTH capability reply
		informing the user that they have permission to create a
		user with the (b) USER_CREATE command.
	</t>
      <t>
		Some values may be reused if they are parameter arguments
		to other commands.
		For example xxxxxx.
	</t>
      <table>
        <thead>
          <tr>
            <th>Decimal Value</th>
            <th>Command / Capability Name</th>
            <th>Brief Description.</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>x</td>
            <td>USER_CERT</td>
            <td>Manage a users certificate.</td>
          </tr>
          <tr>
            <td>x</td>
            <td>USER_CREATE</td>
            <td>
              <t>
					When sent in a capability reply USER_CREATE informs the
					user that they have permission to create users.
					</t>
              <t>
						When sent as a command the USER_CREATE instructs
						the other endpoint to create a named user.
					</t>
            </td>
          </tr>
          <tr>
            <td>x</td>
            <td>USER_DELETE</td>
            <td>Delete a user.</td>
          </tr>
          <tr>
            <td>x</td>
            <td>USER_LIST</td>
            <td>List users and their capabilities.</td>
          </tr>
          <tr>
            <td>x</td>
            <td>USER_PERMISSIONS</td>
            <td>Update user permissions.</td>
          </tr>
          <tr>
            <td>x</td>
            <td>USER_RENAME</td>
            <td>Rename a user.</td>
          </tr>
          <tr>
            <td>x</td>
            <td>USER_RESET</td>
            <td>
					Used to coordinate resetting a users authentication information.
				</td>
          </tr>
          <tr>
            <td>4294967296</td>
            <td>Reserved for future expansion.</td>
            <td>4294967296 has a hex value of: 0xffffffff </td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="AUTHBINARYVALUES_APPENDIX">
      <name>Authentication Enumerated Binary Values</name>
      <t>
		Phoenix is a binary protocol.
		Each value is sent as an unsigned 32-bit integer in xdr format.
	</t>
      <t>
		The values for the commands are arbitrary and were assigned
		as created. There is no plan or origination to the numbers.
		There is no priority or superiority to any value.
		The table is sorted by name, not value.
	</t>
      <t>
		The values are not unique. They are only unique within the context
		in which they are used.
	</t>
      <t>
		Some of these values are reused for other commands.
		For example USER_CREATE is both an (a) AUTH capability reply
		informing the user that they have permission to create a
		user with the (b) USER_CREATE command.
	</t>
      <t>
		Some values may be reused if they are parameter arguments
		to other commands.
		For example xxxxxx.
	</t>
      <table>
        <thead>
          <tr>
            <th>Decimal Value</th>
            <th>Command / Capability Name</th>
            <th>Brief Description.</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>x</td>
            <td>AUTH_TODO</td>
            <td>xxx.</td>
          </tr>
          <tr>
            <td>xxx</td>
            <td>AUTH_xxx</td>
            <td>xxx.</td>
          </tr>
          <tr>
            <td>4294967296</td>
            <td>Reserved for future expansion.</td>
            <td>4294967296 has a hex value of: 0xffffffff </td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="BINARYBINARYVALUES_APPENDIX">
      <name>File and Folder Enumerated Binary Values</name>
      <t>
		Phoenix is a binary protocol.
		Each value is sent as an unsigned 32-bit integer in xdr format.
	</t>
      <t>
		The values for the commands are arbitrary and were assigned
		as created. There is no plan or origination to the numbers.
		There is no priority or superiority to any value.
		The table is sorted by name, not value.
	</t>
      <t>
		The values are not unique. They are only unique within the context
		in which they are used.
	</t>
      <t>
		Some of these values are reused for other commands.
		For example USER_CREATE is both an (a) AUTH capability reply
		informing the user that they have permission to create a
		user with the (b) USER_CREATE command.
	</t>
      <t>
		Some values may be reused if they are parameter arguments
		to other commands.
		For example xxxxxx.
	</t>
      <table>
        <thead>
          <tr>
            <th>Decimal Value</th>
            <th>Command / Capability Name</th>
            <th>Brief Description.</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>x</td>
            <td>FILE_TODO</td>
            <td>xxx.</td>
          </tr>
          <tr>
            <td>xxx</td>
            <td>FILE_xxx</td>
            <td>xxx.</td>
          </tr>
          <tr>
            <td>4294967296</td>
            <td>Reserved for future expansion.</td>
            <td>4294967296 has a hex value of: 0xffffffff </td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="PROTOCOLBINARYVALUES_APPENDIX">
      <name>Protocol Enumerated Binary Values</name>
      <t>
		Phoenix is a binary protocol.
		Each value is sent as an unsigned 32-bit integer in xdr format.
	</t>
      <t>
		The values for the commands are arbitrary and were assigned
		as created. There is no plan or origination to the numbers.
		There is no priority or superiority to any value.
		The table is sorted by name, not value.
	</t>
      <t>
		The values are not unique. They are only unique within the context
		in which they are used.
	</t>
      <t>
		Some of these values are reused for other commands.
		For example USER_CREATE is both an (a) AUTH capability reply
		informing the user that they have permission to create a
		user with the (b) USER_CREATE command.
	</t>
      <t>
		Some values may be reused if they are parameter arguments
		to other commands.
		For example xxxxxx.
	</t>
      <table>
        <thead>
          <tr>
            <th>Decimal Value</th>
            <th>Command / Capability Name</th>
            <th>Brief Description.</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>x</td>
            <td>PROTO_TODO</td>
            <td>xxx.</td>
          </tr>
          <tr>
            <td>xxx</td>
            <td>PROTO_xxx</td>
            <td>xxx.</td>
          </tr>
          <tr>
            <td>4294967296</td>
            <td>Reserved for future expansion.</td>
            <td>4294967296 has a hex value of: 0xffffffff </td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="RPCGEN_SPEC_APPENDIX">
      <name>RPCGEN protocol specification</name>
      <t>
		The following is the extendable RPCGEN specification for the Phoenix
		protocol defined in this document.
	</t>
      <section anchor="CmdAcl_X">
        <name>RPCGEN - Acl</name>
        <sourcecode name="CmdAcl.x" src="CmdAcl.x" type="c++">
		</sourcecode>
      </section>
      <section anchor="CmdAdministration_X">
        <name>RPCGEN - Administration</name>
        <sourcecode name="CmdAdministration.x" src="CmdAdministration.x" type="c++">
		</sourcecode>
      </section>
      <section anchor="CmdAuthenticate_X">
        <name>RPCGEN - Authenticate</name>
        <sourcecode name="CmdAuthenticate.x" src="CmdAuthenticate.x" type="c++">
		</sourcecode>
      </section>
      <section anchor="CmdCapability_X">
        <name>RPCGEN - Capability</name>
        <sourcecode name="CmdCapability.x" src="CmdCapability.x" type="c++">
		</sourcecode>
      </section>
      <section anchor="CmdFolder_X">
        <name>RPCGEN - Folder</name>
        <sourcecode name="CmdFolder.x" src="CmdFolder.x" type="c++">
		</sourcecode>
      </section>
      <section anchor="CmdKeeyAlive_X">
        <name>RPCGEN - KeepAlive</name>
        <sourcecode name="CmdKeepAlive.x" src="CmdKeepAlive.x" type="c++">
		</sourcecode>
      </section>
      <section anchor="CmdNotSupported_X">
        <name>RPCGEN - NotSupported</name>
        <sourcecode name="CmdNotSupported.x" src="CmdNotSupported.x" type="c++">
		</sourcecode>
      </section>
      <section anchor="CmdPing_X">
        <name>RPCGEN - Ping</name>
        <sourcecode name="CmdPing.x" src="CmdPing.x" type="c++">
		</sourcecode>
      </section>
      <section anchor="Commands_X">
        <name>RPCGEN - Commands</name>
        <sourcecode name="Commands.x" src="Commands.x" type="c++">
		</sourcecode>
      </section>
      <section anchor="Email_X">
        <name>RPCGEN - EMail</name>
        <sourcecode name="Email.x" src="Email.x" type="c++">
		</sourcecode>
      </section>
      <section anchor="Mime_X">
        <name>RPCGEN - MIME</name>
        <sourcecode name="Mime.x" src="Mime.x" type="c++">
		</sourcecode>
      </section>
      <section anchor="Phoenix_X">
        <name>RPCGEN - Phoenix</name>
        <sourcecode name="Phoenix.x" src="Phoenix.x" type="c++">
		</sourcecode>
      </section>
      <section anchor="Types_X">
        <name>RPCGEN - Types</name>
        <sourcecode name="Types.x" src="Types.x" type="c++">
		</sourcecode>
      </section>
    </section>
    <section anchor="Acknowledgements" numbered="false">
      <!-- [REPLACE/DELETE] an Acknowledgements section is optional -->
      <name>Acknowledgments</name>
      <t/>
    </section>
    <section anchor="Contributors" numbered="false">
      <!-- [REPLACE/DELETE] a Contributors section is optional -->
      <name>Contributors</name>
      <t>Thanks to all of the contributors. [REPLACE]</t>
      <!-- [CHECK] it is optional to add a <contact> record for some or all contributors -->
    </section>
  </back>
</rfc>
