<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->

<section>
	<name>Commands Overview - Packet and Reply</name>
	<t>
		In addition to the protocols listed in this specification.
		Additional protocols and commands can be added in the future.
		They must follow the same framework listed here.
	</t>
	<t>
		This protocol connects two endpoints over a network and facilitates
		the secure and authorized transfer of MIME objects.
	</t>
	<t>
		This is a binary protocol.
		The payload can be anything, text or binary.
		This protocol was designed to reduce the number of back and forth
		requests and replies between the client and server.
		By using XDR as the format for transferring binary control
		information it is portable to any computer architecture.
		Appendix XXX has the rpcgen definition for the protocol
		defined in this specification.
	</t>
	<t>
		After the connection is successful and authenticated, ether endpoint
		may send commands to the other endpoint.
		When the server initiates an unsolicited command, it could be a
		any kind of notification or message for the client side application
		or the user. It could be reporting errors or updates to
		previous client initiated commands.
	</t>
	<t>
		All commands initiated from the client have even
		numbered command sequence numbers.
		
		All commands initiated from the server have odd
		numbered command sequence numbers.
	</t>
	<t>
		Some commands expect a command reply.
		Other commands do not expect a command reply.
		An example of a command that expects a reply is the ping command.
		An example of a command that does not expect a reply is the keep-alive
		command.
		Conceptually there are two kinds of commands:
	</t>
	<dl>
		<dt>Directive commands:</dt>
		<dd>
			A directive type command expects the other endpoint to process
			the command and possibly reply with some results.
			An example could be: Send me an index of my emails in my InBox.
			The client would expect a result.
			Another example is a bye command, once sent, no reply is expected.
		</dd>
		<dt>Request commands:</dt>
		<dd>
			A request type command may or might not have any reply.
			For example, a keep-alive command is a request to not
			timeout and has no reply.
			And a send new email notifications command would expect
			zero or more replies and it would not require them, as they
			might not happen.
		</dd>
	</dl>
	<t>
		These are not specific protocol entities, these concepts will
		be used to describe the expected behavior when one of these
		are transmitted.
	</t>
	<section anchor="PACKET_SUMMARY">
		<name>Packet Overview</name>
		<t>
			All commands are sent in a packet.
			A packet has two parts:
		</t>
		<ol>
			<li>The packet header.</li>
			<li>The packet body.</li>
		</ol>
		<section>
			<name>Packet Header</name>
			<t>
				The packet header has one value, the total length
				of the packet body, and payload sent as an
				unsigned 64-bit integer	in network byte order.
				The length does not include its own length.
				It is the total length that follows the length value.
			</t>
			<table>
				<name>Packet Header ABNF/XDR Mapping</name>
				<thead>
					<tr>
						<th>
							ABNF Name
						</th>
						<th>
							XDR Type
						</th>
						<th>
							Description
						</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							PacketLength
						</td>
						<td>
							uint64_t
						</td>
						<td>
							<t>
								The nuber of octets that follow this value that
								are part of this packet.
							</t>
							<t>
								<br/>
								XDR API: xdr_PacketLength();
							</t>
						</td>
					</tr>
				</tbody>
			</table>
			<section>
				<name>Packet Header ABNF</name>
				<t>
					ABNF:
				</t>
				<figure>
					<name>Packet Header ABNF</name>

					<artwork type="abnf" name="" align="left" alt=""><![CDATA[
PacketLength      = uint64_t
]]></artwork>
				</figure>
			</section>
			<section>
				<name>Packet Header XDR</name>
				<t>
					XDR Definition:
				</t>
				<figure>
					<name>Packet Header XDR</name>
					<artwork type="abnf" name="" align="left" alt=""><![CDATA[
typedef uint64_t PacketLength;
]]></artwork>
				</figure>
			</section>
		</section>

		<section>
			<name>Packet Body</name>
			<t>
				The packet body is divided into three parts:
			</t>
			<table>
				<name>Packet Body ABNF/XDR Mapping</name>
				<thead>
					<tr>
						<th>
							ABNF Name
						</th>
						<th>
							XDR Type
						</th>
						<th>
							Description
						</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							SEQ
						</td>
						<td>
							SEQ
						</td>
						<td>
							<t>
								The Command SEQ is a 32-bit unsigned integer sent
								in network byte order.
								This SEQ is an even number when initiated from
								the client,	and an odd number when initiated
								from the server.
							</t>
							<t>
								The first SEQ value sent from the client is zero (0)
								and is incremented by two each time.
							</t>
							<t>
								The first SEQ value sent from the server is one (1)
								and is incremented by two each time.
							</t>
							<t>
								In the event an endpoint command SEQ reaches its maximum
								value, then its numbering starts over at zero (0) for
								the client and one (1) for the server.
								An implementation must keep track of outstanding
								commands and not accidentally re-issue the same
								SEQ that may still get replies from the other endpoint.
							</t>
							<t>
								<br/>
								XDR API: xdr_SEQ();
							</t>
						</td>
					</tr>
					<tr>
						<td>
							CMD
						</td>
						<td>
							Command
						</td>
						<td>
							<t>
								A command (CMD) is a unsigned integer that
								specifics a unique operation that describes
								and defines the data that follows.
								The command are specified in this specification.
							</t>
							<t>
								<br/>
								XDR API: xdr_Command();
							</t>
						</td>
					</tr>
					<tr>
						<td>
							CmdPayload
						</td>
						<td>
							CmdPayload
						</td>
						<td>
							<t>
								The Payload is whatever data follows the command.
								In some cases it is a blob of opaque data.
								In other caes it is a structured XDR set of data.
								See the specific CMD for details.
							</t>
							<t>
								XDR API: xdr_CmdPayload();
							</t>
						</td>
					</tr>
					<tr>
						<td>
							PacketBody
						</td>
						<td>
							PacketBody
						</td>
						<td>
							<t>
								The packet body.
							</t>
							<t>
								XDR API: xdr_PacketBody();
							</t>
						</td>
					</tr>
				</tbody>
			</table>
			<section>
				<name>Packet Body ABNF</name>
				<t>
					ABNF:
				</t>
				<figure>
					<name>Packet Body ABNF</name>
					<artwork type="abnf" name="" align="left" alt=""><![CDATA[
SEQ        = uint32_t

CMD        = uint32_t

CmdPayload = *uint8_t

PacketBody = SEQ CMD CmdPayload
]]></artwork>
				</figure>
			</section>
			<section>
				<name>Packet Body XDR</name>
				<t>
					XDR Definition:
				</t>
				<figure>
					<name>Packet Body XDR</name>
					<artwork type="abnf" name="" align="left" alt=""><![CDATA[
typedef uint32_t  SEQ;

typedef uint32_t  CMD;

typedef uint8_t * CmdPayload;

struct PacketBody {
    SEQ Seq;
    CMD Command;
		PacketBody Payload;
};
PacketBody = SEQ CMD
]]></artwork>
				</figure>
			</section>
		</section>
			
	</section>
	<section anchor="PACKET_REPLY_SUMMARY">
		<name>Packet Reply Overview</name>
		<t>
			All replies to a command are also a command packet.
			They contain the same command SEQ and command
			as the original packet.
			The endpoint recognizes it is a reply because:
		</t>
		<ul>
			<li>
				The	command SEQ matches one that is waiting a reply.
			</li>
			<li>
				When the client gets an even numbered SEQ, it can only
				be a reply.
			</li>
			<li>
				When the server gets an odd numbered
				SEQ, it can only be a reply.
			</li>
		</ul>
		<t>
			Some commands have zero to many replies.
			Each of these multiple replies contains the same SEQ as the
			original command. An example, the client sends a request
			to be notified when new email arrives and uses command
			SEQ 20. Each time a new email arrives, a reply will
			be sent from the server with a command SEQ of 20.
			And over time, the client may get many with a SEQ of 20
			as new emails arrive on the server.
		</t>
	</section>
</section>
