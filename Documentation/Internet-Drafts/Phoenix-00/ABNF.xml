<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->

<section xmlns:xi="http://www.w3.org/2001/XInclude">
	<name>ABNF, Notes, and Definitions</name>
	<section>
		<name>XDR TYPE - Meaning - Informative</name>
		<t>
			The meaning of "XDR TYPE" in this specification refers
			to the "C" code API.
			For every "XDR TYPE" "foo", is a "C" code API of "xdr_foo(...)".
			The purpose of "XDR TYPE" is to guide implementors and is to be
			considered informative and not normative information.
		</t>
		<t>
			In some cases the "xdr_foo(...)" API is part of system libraries,
			and in other cases it is the result of processing the normative XDR
			definition files provided in this specification with the tools
			in the sample implementation or open-source XDR
			<xref target="rpcgenopensource">"rpcgen / rpcgen++"</xref> tools.
			<xref target="rpcgendocs">"rpcgen documentation"</xref>.
		</t>
		<t>
			In most cases the "XDR TYPE" is used in a ".x" XDR definition
			file as the variable type.
			In some cases like "string", and "opaque", they must be
			defined as arrays.
			Any other exceptions are added to the informative description
			in this specifications when needed:
		</t>
		<table>
			<name>XDR string and opaque are arrays.</name>
			<thead>
				<tr>
					<th>
						NAME
					</th>
					<th>
						Description:
					</th>
					<th>
						XDR API
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>
						string
					</td>
					<td>
						<t>
							Is an XDR array.
							See <xref target="rpcgendocs"/>.
						</t>
						<t>
							The ABNF definition for opaque is in <xref target="GenericAbnf"/>
						</t>
						<t>
							<br/>
							"string MyVariableName&lt;&gt;;"
							<br/>
						</t>
					</td>
					<td>
						xdr_string()
					</td>
				</tr>
				<tr>
					<td>
						opaque
					</td>
					<td>
						<t>
							Is an XDR array.
							See <xref target="rpcgendocs"/>.
						</t>
						<t>
							The ABNF definition for opaque is in <xref target="GenericAbnf"/>
						</t>
						<t>
							<br/>
							"opaque MyOpaqueData&lt;&gt;;"
							<br/>
						</t>
					</td>
					<td>
						xdr_opaque()
					</td>
				</tr>
			</tbody>
		</table>
	</section>
	<section>
		<name>ABNF Number of bits in value</name>
		<t>
			This specification adds some syntax to <xref target="RFC5234">ABNF</xref>
			to deal with bit width in a binary number.
		</t>
		<t>
			Terminals may specify a bit width.
			That is the number of bits in the value.
		</t>
		<t>
			<xref target="RFC5234" section="2.3">Terminal Values</xref>
			is within this specification defined to be:
		</t>
		<t>
			b = binary / binary:width
			<br/>
			<br/>
			d = decimal / decimal:width
			<br/>
			<br/>
			x = hexadecimal / hexadecimal:width
		</t>
		<t>
			Where: with is the number of bits in the value.
			And must be an unsigned integer greater than zero.
		</t>
		<t>
			When the left side has a width: 
			The number of bits on the left side must equal
			the number of bits on the right side.
		</t>
		<t>
			The most significant values are placed to the left of
			lesser signification values in the rule:
		</t>
		<t>
			In this example A Header is 32-bits in size
			and is composed of an 8-bit (Offset), 2-bit (Flags or F),
			and 22-bit (Length) value.
		</t>
		<figure anchor="Header32Example">
	<artwork type="abnf" name="" align="left" alt=""><![CDATA[
Header:32 = Offset:8 Flags:2 Length:22
]]></artwork>
</figure>
		<t>
		</t>
		<t>
			Example pseudo code for the ABNF in
			<xref target="Header32Example"/> could be:
		</t>
		<figure anchor="Header32ExamplePseudo">
		<sourcecode>

// Header is a 32-bit unsigned integer.
// Offset is an 8-bit unsigned integer.
// Flags (F) is a 2-bit unsigned integer.
// Length is a 22-bit unsigned integer
//
Header = (Offset &lt;&lt; 24) | (Flags &lt;&lt; 22) | Length;

		</sourcecode>
		</figure>

		<t>
			The pseudo code in
			<xref target="Header32ExamplePseudo"/>
			shifts the 8-bit "Offset" over 24 bits to the left, then
			shifts the 2-bit value "Flags (F)" over 22 bits,
			then, places the lower 24-bits "Length" into the results.

			The result would be all three values into the
			one 32-bit result as illustrated in <xref target="ABNF-00"/>:
		</t>

		<figure anchor="ABNF-00" align="center">
			<name>Packed Bit Example</name>
			<artset>
				<artwork type="ascii-art" src="ABNF-00.txt"/>
				<artwork type="svg" src="ABNF-00.svg"/>
			</artset>
		</figure>
	</section>

	<section>
		<name>Common Definitions</name>
		<table>
			<name>Common ABNF/XDR Mapping</name>
			<thead>
				<tr>
					<th>
						TYPE
					</th>
					<th>
						Notes
					</th>
					<th>
						XDR API
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>
						uint8_t
					</td>
					<td>
						<t>
							An 8-bit unsigned integer.
						</t>
					</td>
					<td>
						xdr_uint8_t()
					</td>
				</tr>
				<tr>
					<td>
						uint16_t
					</td>
					<td>
						<t>
							A 16-bit unsigned integer.
						</t>
					</td>
					<td>
						xdr_uint16_t()
					</td>
				</tr>
				<tr>
					<td>
						uint32_t
					</td>
					<td>
						<t>
							A 32-bit unsigned integer.
						</t>
					</td>
					<td>
						xdr_uint32_t()
					</td>
				</tr>
				<tr>
					<td>
						uint64_t
					</td>
					<td>
						<t>
							A 64-bit unsigned integer.
						</t>
					</td>
					<td>
						xdr_uint64_t()
					</td>
				</tr>
				<tr>
					<td>
						string
					</td>
					<td>
						<t>
							A string of UTF-8 characters.
						</t>
					</td>
					<td>
						xdr_string()
					</td>
				</tr>
				<tr>
					<td>
						opaque
					</td>
					<td>
						<t>
							An array of 8-bit values that will not be
							XDR encoded or XDR decoded when tranfering the data
							over this protcol.
						</t>
					</td>
					<td>
						xdr_opaque()
					</td>
				</tr>
				<tr>
					<td>
						Op
					</td>
					<td>
						An 8-bit value.
					</td>
					<td>
						xdr_Op()
					</td>
				</tr>
				<tr>
					<td>
						OpSet_t
					</td>
					<td>
						An 8-bit value.
						Signifies the operation will set a value.
						This is used in a few places to signifiy
						the operation to apply to any included data.
					</td>
					<td>
						xdr_Op() With the value cat to a (Op).
					</td>
				</tr>
				<tr>
					<td>
						OpGet_t
					</td>
					<td>
						An 8-bit value. 
						Signifies the operation will get a value.
					</td>
					<td>
						xdr_Op() With the value cat to a (Op).
					</td>
				</tr>
				<tr>
					<td>
						OpUpdate_t
					</td>
					<td>
						An 8-bit value.
						Signifies the operation will update an existing value.
					</td>
					<td>
						xdr_Op() With the value cat to a (Op).
					</td>
				</tr>
				<tr>
					<td>
						OpDelete_t
					</td>
					<td>
						An 8-bit value.
						Signifies the operation will delete key/value pair.
					</td>
					<td>
						xdr_Op() With the value cat to a (Op).
					</td>
				</tr>
				<tr>
					<td>
						true_t
					</td>
					<td>
						An 8-bit value.
						A value of true.
					</td>
					<td>
						xdr_false_t()
					</td>
				</tr>
				<tr>
					<td>
						false_t
					</td>
					<td>
						An 8-bit value.
						A value of false.
					</td>
					<td>
						xdr_true_t()
					</td>
				</tr>
				<tr>
					<td>
						enabled
					</td>
					<td>
						An 8-bit value.
						With a value of true_t or false_t
					</td>
					<td>
						xdr_enabled()
					</td>
				</tr>
			</tbody>
		</table>

		<section>
			<name>Common Definitions - ABNF</name>
			<figure anchor="GenericAbnf">
				<name>Common ABNF Definitions</name>
				<xi:include href="include/01-ABNF-ABNF.xml"/>
			</figure>
		</section>

		<section>
			<name>Common Definitions - XDR</name>
			<figure>
				<name>Common Definitions - XDR</name>
				<xi:include href="include/01-ABNF-XDR.xml"/>
			</figure>
		</section>
	</section>
	
	<section anchor="StringRef">
		<name>StringRef</name>
		<t>
			This protocol references strings in existing MIME objects
			by octet offset into the MIME object.
			This is is called a StringRef.
			All strings can be referenced by using a total of 8 octets.
			A StringRef consists of two parts:
		</t>
		<t>
			The StringRef does not contain the string, it is a 
			reference an existing string in a MIME object.
		</t>
		<table>
			<name>StringRef ABNF/XDR Mapping</name>
			<thead>
				<tr>
					<th>Name</th>
					<th>Description</th>
					<th>XDR API</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>Offset_t</td>
					<td>
						The octet count to the start of the string with zero being the
						first octet in the message.
					</td>
					<td>
						xdr_Offset_t()
					</td>
				</tr>
				<tr>
					<td>Length_t</td>
					<td>
						The length in octets of the string.
					</td>
					<td>
						xdr_Length_t()
					</td>
				</tr>
				<tr>
					<td>StringRef</td>
					<td>
						A String reference object.
					</td>
					<td>
						xdr_StringRef()
					</td>
				</tr>
			</tbody>
		</table>
		<t>
			A StringRef over the wire is 8 octets in size.
		</t>
		<figure anchor="StringRefFigure" align="center">
			<name>StringRef Format</name>
			<artset>
				<artwork type="ascii-art" src="StringRef-00.txt"/>
				<artwork type="svg" src="StringRef-00.svg"/>
			</artset>
		</figure>

		<t>
			ABNF:
		</t>
		<section>
			<name>StringRef ABNF</name>
			<figure anchor="StringRefABNF">
				<name>StringRef ABNF</name>
				<xi:include href="include/02-StringRef-ABNF.xml"/>
			</figure>
		</section>
		<section>
			<name>StringRef XDR</name>
			<t>
				The XDR definitions are:
			</t>
			<figure anchor="StringRefXDR">
				<name>StringRef ABNF</name>
				<xi:include href="include/02-StringRef-XDR.xml"/>
			</figure>
		</section>
	</section>
	
</section>
<!-- [CHECK] The 'Requirements Language' section is optional -->
